Development of a 2D Top-Down Action role-playing game in Unity 
 
Cooper Tran
Senior Student of Computer Science
UHD Texas
Houston, USA
cuongtran2196@gmail.com
  
 
 
 
Abstract—This paper presents the design and development of Ninja Adventure, a 2D top-down action role-playing game (RPG) created using the Unity game engine. The game features a ninja character who battles enemies, collects items, upgrades abilities, and faces powerful bosses. This project demonstrates how to build a complete game with multiple interconnected systems: intelligent enemy behaviors, real-time combat with combos and dodging, inventory management, character progression through skill trees, dialog conversations with NPCs, and boss battles with unique mechanics. The game was developed over approximately twelve weeks, with each week adding new features and refinements. This paper explains how each major system works. The goal is to provide a clear guide that helps other game developers understand how to create similar 2D action RPGs, regardless of their technical background.
Keywords—2D Game Development, Unity Engine, Top-Down RPG, Game Design, Artificial Intelligence, State Machine, Inventory System, Skill Tree, Combat System, Boss Design
I.	INTRODUCTION
A.	Background and Motivation
Video games have been entertaining people for decades, and among all the different types of games, 2D action role-playing games (RPGs) remain incredibly popular. Games like The Legend of Zelda and classic arcade action games showed us that simple 2D graphics can create exciting adventures with memorable characters and challenging gameplay. Today, with powerful game engines like Unity available for free, anyone with dedication and creativity can make their own games.
Ninja Adventure is a complete 2D action RPG where players control a ninja warrior exploring a dangerous world filled with enemies, treasures, and powerful bosses. The game was built from scratch using Unity 2025. During development, the project grew from a simple moving character to a full game with combat combos, enemy artificial intelligence, an inventory system for managing items and weapons, skill trees for character upgrades, conversations with non-playable characters (NPCs), many different type of enemies and three unique boss fights.
The motivation behind this project was to learn how professional games are made by building one from the ground up. Rather than just studying game development theory, this project involved solving real problems: How do you make enemies that chase and attack the player intelligently? How do you create satisfying combat that feels responsive? How do you manage player progression so it stays interesting? Each challenge was tackled one system at a time, building a complete playable game.
B.	Project Objectives
The main goal of this project was to create a fun, complete 2D action RPG while learning professional game development practices. The project focused on nine core objectives that together form a cohesive gameplay experience.
1)	The player controls needed to feel smooth and responsive, allowing the character to move, attack with various weapons, and dodge enemy attacks with precise timing.
2)	AI systems would make enemies patrol designated areas, detect the player when nearby, chase and attack at appropriate moments.
3)	The combat system would deliver satisfying gameplay through both melee and ranged weapons, combo attack chains, dodge rolls granting temporary invincibility, and clear visual feedback confirming successful hits.
4)	Three unique boss encounters would challenge players with distinct attack patterns and special mechanics that reward learning and skill development.
5)	Character progression systems would allow players to gain experience from defeated enemies, level up to unlock skill points, and strategically upgrade their abilities through a skill tree.
6)	Inventory and shopping mechanics would let players collect items from fallen enemies, manage limited inventory space, visit shops to buy and sell equipment, and swap between different weapons.
7)	A dialog system would facilitate conversations with NPCs, supporting branching choices that lead to different outcomes and automatic reward distribution.
8)	The user interface would provide clear information displays ensuring players always understand their current health, mana reserves, inventory contents, and available skills without confusion.
9)	World building through multiple interconnected levels created with a dedicated level editor would enable smooth transitions between areas while maintaining game state persistence.
C.	Paper Organization
This paper is structured to provide comprehensive coverage of both theoretical foundations and practical implementation details. Section II examines existing research in game development, reviewing architectural patterns for code organization, combat system design principles, inventory management approaches, character progression mechanisms, dialog interaction frameworks, and boss encounter design philosophies that informed Ninja Adventure's development. Section III presents the complete system implementation, beginning with overall game architecture and project structure, then proceeding through detailed explanations of core systems including character controllers and state management, artificial intelligence for enemies and NPCs, combat mechanics and weapon systems, inventory and economy implementations, dialog and narrative frameworks, user interface designs, and scene transition management with persistent state handling. Section IV analyzes development outcomes, discusses implementation limitations, and proposes future enhancements that would extend gameplay depth and player experience. Section V concludes by synthesizing technical accomplishments, gameplay achievements, and lessons learned throughout the twelve-week development cycle.
II.	LITERATURE REVIEW
A.	Game Architecture and Organization
As games become more complex, developers need better ways to organize their code. Just like building a house requires a blueprint, building a game requires a plan for how all the pieces fit together. Unity uses a component-based system where game objects (like the player or enemies) can have different components attached to them (like health, movement, or graphics). Ninja Adventure uses a "controller-state" pattern, which is like giving each character a brain (controller) that can switch between different modes (states) - for example, an enemy might switch between "patrolling," "chasing," and "attacking" states.
Contemporary research on Unity game development demonstrates the effectiveness of Finite State Machines (FSM) for organizing behavioral complexity in character-driven games. FSMs provide a structured approach where entities transition between discrete behavioral states based on conditional triggers, creating predictable and maintainable AI logic. Each state encapsulates specific behaviors and transition rules, allowing developers to visualize character decision-making as directed graphs where nodes represent states and edges represent transition conditions. Ninja Adventure adopts this proven architecture but extends its application beyond traditional enemy AI to encompass all interactive characters including the player controller, various enemy archetypes, boss entities, and non-playable characters. This unified approach enables code reuse across character types while maintaining behavioral flexibility, as the same state machine framework supports both simple patrol behaviors in basic enemies and complex multi-phase attack patterns in boss encounters. The architecture's modularity facilitates rapid prototyping of new character types by composing existing state components in novel configurations.
B.	Combat Systems
Good combat in action games requires balancing challenge with player satisfaction. Combo systems (where attacking multiple times in sequence performs different moves) add depth while staying accessible to new players. The key is making combat feel responsive - when players press attack, something should happen immediately, and when they hit an enemy, it should look and feel impactful.
The dodge roll with invincibility frames (i-frames) is a common mechanic in action games. During a dodge, the player can't be hurt for a brief moment, giving skilled players a way to avoid damage by timing their dodges correctly. The visual "afterimage" effect (where ghostly copies of the character fade out behind them) helps players understand when they're invincible. Ninja Adventure carefully balances dodge distance, speed, and cooldown to make it useful without being too powerful. 
C.	Inventory and Item Management
RPGs need systems for collecting, storing, and using items. The inventory must be easy to understand and use - players should not struggle to find their health potions in the middle of a fight. Ninja Adventure uses a 9-slot inventory where each slot can hold one weapon or multiple copies of the same item (stacking). Players can drag items between slots with the mouse or use number keys (1-9) for quick access during combat.
The shop system lets players buy items with gold earned from defeating enemies and sell unwanted items for half their purchase price. This creates interesting decisions: Should I save gold for better equipment later, or buy health potions now?
D.	Character Progression
Leveling up and gaining new abilities keeps players engaged over long play sessions. Skill trees present players with choices about how to develop their character. Ninja Adventure's skill tree uses a prerequisite system - certain powerful skills can only be unlocked after maxing out simpler skills first. This guides new players toward building a solid foundation before accessing advanced abilities.
The skill system supports both passive enhancements, such as permanently increasing health, and active abilities that improve weapon handling, like faster attack speed. This flexibility is achieved through a unified code structure that accommodates both types seamlessly.
E.	Dialog and NPC Interaction
NPCs bring game worlds to life by giving players someone to talk to and learn from. Dialog systems range from simple text boxes to complex branching conversations where player choices matter. Ninja Adventure's dialog system supports branching - NPCs can offer multiple response options, and different choices can lead to different outcomes and rewards.
NPCs also need behaviors beyond just standing still. Ninja Adventure's NPCs can idle, wander around their area, and stop to talk when the player approaches. This makes the world feel more alive and believable. 
F.	Boss Design
Boss battles are designed to be memorable milestones that challenge players to apply all the skills they have learned throughout the game. A well-crafted boss encounter should feature clear and predictable attack patterns that players can recognize and counter through observation and practice. Adding multiple phases, where the boss changes tactics as its health decreases, keeps the fight engaging and prevents it from feeling repetitive, ensuring that the tension remains high until the end.
In Ninja Adventure, three unique bosses showcase this design philosophy. The Giant Raccoon uses a powerful jump attack that pushes the player toward the edge of the screen; stepping outside the map border results in health loss, so players must learn proper positioning to survive. The Giant Summoner introduces complexity with a two-phase battle, starting by spawning waves of minions and later switching to a defensive stance when its health is low. Finally, the Giant Red Samurai serves as the ultimate challenge, relentlessly chasing the player and executing rapid dash-forward combos with double strikes, demanding precise timing and quick reactions. Each boss encourages strategic thinking and adaptability, creating a rewarding and unforgettable experience.
III.	PLAYER SYSTEM IMPLEMENTATION
A.	Game Architecture
Ninja Adventure is a single-player top-down action RPG where players control a ninja exploring dangerous environments while fighting enemies and collecting items. The game emphasizes responsive controls, clear visual feedback, and meaningful player choices in character development. Development spanned twelve weeks using Unity 2025 as the primary engine, with code organized into feature-based modules to maintain clarity and scalability.
The architecture employs a controller-state pattern as its core organizational principle. Each character type including players, enemies, and NPCs implements a controller component that manages state transitions. States represent distinct behaviors such as idle, patrol, chase, attack, and death. Only one state executes at any given time, preventing conflicting behaviors. Controllers evaluate conditions each frame to determine appropriate state transitions, creating responsive and predictable character behaviors.
Event-driven communication connects independent systems without creating tight coupling. When significant game events occur, such as a character taking damage or collecting an item, the source system broadcasts an event notification. Other systems subscribe to relevant events and respond appropriately. For example, when the health component fires an "OnDamaged" event, the UI system updates health bar displays, the audio system plays hurt sounds, and the visual effects system triggers damage flash animations. This architecture allows new features to integrate without modifying existing code.
Scriptable Object data containers store game content separately from code logic. Weapons, items, skills, and dialog conversations exist as data assets that designers can modify through Unity's editor without programming knowledge. This separation accelerates iteration cycles for balancing gameplay values and adding content variations.
TABLE I. 	PROJECT STRUCTURE
Folder Name	Purpose
Player	Player character movement, attacks, and dodging
Enemy	Enemy and boss AI behaviors
Character	Health, mana, and stats shared by all characters
Weapon	Different weapon types and damage systems
Inventory	Picking up, storing, and using items
Dialog	Conversations with NPCs
SkillTree	Upgrading abilities
UI	All menus, health bars, and on-screen displays
System	Global managers for scene loading and audio
Environment	Ladders, gates, traps, and breakable objects

The development process relied on a suite of tools and technologies. Unity 2025 served as the core game engine, while C# handled gameplay programming.. LDtk supported level design with seamless Unity integration, and LibreSprite facilitated pixel art creation and animation. Visual Studio Code was used for coding, and Git ensured robust version control throughout the project.
B.	Core Systems
1)	Character controllers and state management
Every character in Ninja Adventure employs a controller component that manages behavioral transitions through discrete states. Each state represents a distinct behavioral mode such as idle, movement, attack, or dodge. The controller maintains responsibility for physics integration, state transition evaluation, knockback responses, and death sequence management. Meanwhile, individual states determine movement intentions, execute attack sequences with proper animation timing, and configure animation parameters appropriate to their behavior.
The player controller uses a structured priority system to handle conflicting inputs predictably:
a)	Death State – Takes absolute precedence. When the character is defeated, all other inputs are ignored.
b)	Dodge State – Overrides every other action when available, allowing defensive maneuvers to interrupt ongoing attacks.
c)	Attack State – Holds third priority, initiating combo sequences when the attack button is pressed.
d)	Movement State – Translating directional input into character motion.
e)	Idle State – Activates when no inputs are detected, playing ambient standing.
2)	Health, mana, and stats
Every character in the game has three interrelated components that work together to manage attributes and resources, forming a cohesive character stat system. These components function similarly to a character sheet in tabletop role-playing games, tracking numerical values that determine combat effectiveness and survivability.
The C_Stats component stores all attributes defining a character's capabilities. This includes offensive statistics like attack damage for physical attacks and ability power for magical attacks, along with critical hit chance for bonus damage opportunities. Defensive attributes include maximum health pool, armor for physical damage reduction, and magic resistance for magical damage mitigation. Resource management tracks maximum mana capacity. Mobility characteristics determine movement speed, dodge roll distance traveled, and cooldown duration between dodges. Survivability features encompass life steal percentage converting damage dealt to healing and health regeneration over time.
The C_Health component manages all damage and healing transactions for the character. When damage is received, this component calculates the effective damage after armor mitigation using the diminishing returns formula described below. It announces damage events through an event system, allowing other systems to respond appropriately - the UI updates health bars, the audio system plays hurt sounds, and visual effects trigger damage flashes. This component also tracks temporary invincibility states during dodge rolls or ultimate abilities, preventing damage during these windows. For environmental hazards like drowning zones or fatal falls, it provides instant-kill functionality that bypasses normal damage calculations.
The C_Mana component handles magical resource management for abilities. Before any mana-consuming action executes, this component validates sufficient mana availability and returns a Boolean success indicator. It announces mana changes through events so the UI can update the mana bar display in real-time.
The armor system uses a straightforward approach: each point of armor reduces incoming damage by a fixed percentage. For example, 50 armor can cut damage in half. To prevent players from becoming overpowered, armor is capped and tied to skill progression. Each defense skill upgrade adds 5% armor, allowing players to gradually improve protection while maintaining game balance. This design ensures progression feels rewarding without removing the challenge.
3)	Stat manager for player
The Stats Manager serves as a central coordinator that ensures all stat-related information remains synchronized across the game systems. When any stat-modifying event occurs, such as using an item, leveling up, or activating a skill tree upgrade, the transaction must pass through the Stats Manager to maintain data consistency and prevent synchronization bugs where different systems hold conflicting values for the same stat.
The system recognizes three distinct stat effect durations. Instant effects apply once immediately and then expire, such as healing potions that restore 50 health points. Permanent effects remain active indefinitely until explicitly removed, such as skill tree upgrades that increase maximum health by 20 points. Timed effects stay active for a specified duration and then automatically expire, such as strength buffs that add 15 attack damage for 10 seconds.
When a stat change request arrives, the manager executes a synchronized update sequence consisting of four stages.
a)	First, the system recalculates all final stat values by summing base statistics with equipment bonuses and temporary effect modifiers.
b)	Next, the system validates resource pools to ensure current health does not exceed the new maximum health value, preventing over healing.
c)	Then, the system broadcasts change notifications through the event system so that all listening systems can respond appropriately.
d)	Finally, registered listeners including user interface panels, visual effect systems, and gameplay logic receive the notifications and refresh their displays or states accordingly.
 This approach prevents common bugs such as health bar displays showing different values than actual health pools, which occur when systems update at different times or when synchronization events are missed.
C.	Artificial Intelligence
1)	Regular enemy AI
Regular enemies implement four distinct behavioral states that manage their decision-making processes through a finite state machine architecture.
The Idle state represents the enemy's default resting behavior where it stands stationary playing an idle animation cycle. This state activates when no player is detected nearby and serves as the baseline behavior between patrol movements. This state also activates when the enemy reaches the edge of its wandering area, creating the impression that it is pausing to decide where to patrol next. If the player enters detection range during idle, the state immediately switches to Chase.
The Wander state implements ambient movement that makes levels feel populated even when the player is distant. The enemy selects a random direction, moves slowly for a short duration, then selects a new random direction when reach the border of wandering area. This creates natural-looking patrol behavior without requiring explicitly defined patrol paths. Detection range constantly monitors for player presence, transitioning to Chase immediately upon detection regardless of current wander direction.
The Chase state calculates the direction vector toward the player's current position each frame and moves at full speed along that vector. Rather than running directly into the player and overlapping, the state maintains a minimum distance equal to the attack range, stopping just outside melee distance. This positioning prepares the enemy for attack execution while preventing visual collision overlap. The state continuously tracks player movement, updating the direction vector in real-time to follow evasive maneuvers. When the player exits detection range, Chase returns to Wander. When the player enters attack range and the enemy is facing the correct direction, the state transitions to Attack.
The Attack state executes the complete attack sequence including animation, hitbox timing, and cooldown management. The enemy faces the player, triggers the attack animation, and enables the weapon hitbox at the precise moment calculated using time-based animation synchronization. After the attack completes, a cooldown period prevents immediate re-attacking, creating combat patterns that players can learn to exploit. Once cooldown expires, the state returns to Chase to reposition for the next attack opportunity.
The controller continuously evaluates state transition conditions every frame. The evaluation follows a priority hierarchy where attack opportunities take over movement decisions. If the player is within attack range AND the enemy is facing the correct direction AND the attack cooldown has expired, the Attack state activates immediately. Otherwise, if the player is within detection range, Chase state maintains pursuit. In the absence of player detection, the enemy alternates between Idle and Wander states based on default setting.
Detection range implements a circular area around the enemy. When the player's position enters this circle, the enemy "sees" them and begins pursuit. This creates the classic aggro behavior familiar in action RPGs where walking near enemies triggers combat encounters. Detection range typically exceeds attack range by a significant margin, giving enemies time to close distance before engaging.
2)	Boss AI
Bosses represent special enemies with unique mechanics designed to create memorable combat encounters that test player mastery of game systems. Unlike regular enemies that share a common AI template, each boss implements specialized behavior patterns and attack sequences.
 
The Giant Raccoon boss, designated as the mini boss encounter in Map 2, implements a charger archetype with two distinct attack patterns. The normal attack executes a bull-like charge where the boss becomes a mobile hitbox dealing collision damage. Using the time-based animation system, the attack waits for the charge animation to complete, then initiates a high-speed dash. During the dash, an afterimage trail spawns to provide visual feedback of the rapid movement path. The special attack features a jumping ground slam mechanic where the boss leaps into the air, then impacts the ground creating an area-of-effect. This deals damage to player and applies knockback force pushing characters outward from the impact center. The boss randomly selects between normal charge and special jump attacks when within attack range and cooldown permits. Additionally, the boss maintains collision damage separate from weapon hitboxes - physical contact with the moving boss deals damage with an independent cooldown timer.
 
The Giant Summoner boss introduces a two-phase encounter where behavior patterns change dramatically based on remaining health percentage. Phase 1 activates from 100% to 20% health (can be tune in inspector) and implements aggressive chase behavior combined with periodic minion spawning. Every X seconds, the boss summons X enemy minions. The summoning process renders the boss vulnerable. The boss will be idle for X seconds when casting, giving the player a chance to attack back. When spawning minions, the boss uses circular distribution mathematics to spread spawns evenly around its position. Each spawned minion receives an initial outward velocity impulse to visually separate them from overlapping positions. Phase 2 activates when health drops to 20% or below and completely changes behavior to defensive retreat mode. When the player approaches within X units distance, the boss retreats away from the player for X seconds, then enters a X seconds vulnerable cooldown before retreat ability recharges. The phase transition triggers an emergency spawn of X minions immediately. This phase shift creates kiting gameplay where players must chase the retreating boss and maximize damage output during vulnerable windows while managing spawned minions that accumulate over time.
 
The Giant Red Samurai boss serves as the final encounter and implements the most mechanically complex behavior in the game. The normal attack executes a standard weapon slash at close range. The special attack delivers the boss's signature double-dash combo sequence which proceeds as follows: first, a X seconds charge animation provides clear visual telegraph for the incoming attack; second, the boss dashes toward the player at high speed with weapon hitbox active for the initial hit; third, the dash continues for X seconds total with afterimage effects enhancing visibility; fourth, a brief X seconds gap occurs where the hitbox briefly deactivates; fifth, the weapon hitbox reactivates for the second hit while maintaining dash momentum; sixth, the attack concludes and a lengthy cooldown period begins. This double-hit mechanic creates a timing puzzle where dodging only the first strike leaves the player vulnerable to the second strike. Players must either time invincibility frames to cover both hits simultaneously. The chase behavior prioritizes vertical alignment first before horizontal approach, making the boss's intentions highly readable to observant players.
3)	Non-playable characters (NPC) AI
NPCs that facilitate dialog interactions implement a simplified version of the controller-state architecture optimized for conversational scenarios rather than combat. These characters serve as quest givers, merchants, and story deliveries throughout the game world.
 
NPC controllers manage three distinct behavioral states. The Idle state represents the default stationary behavior where NPCs stand in designated positions playing idle animation loops. This state activates when no player interaction is occurring and the NPC has not entered wander mode. The Wander state implements localized ambient movement where NPCs walk randomly within a small radius around their spawn point. This creates the appearance of living, breathing characters rather than static objects. The Talk state activates when players press the interact button while positioned within the NPC's trigger zone. Upon activation, the NPC immediately stops all movement, rotates to face the player character, and hands control to the Dialog Manager which displays conversation UI and manages branching dialog trees. When the conversation concludes, whether through normal completion or player cancellation, the NPC restores its previous facing direction and returns to either Idle or Wander behavior depending on its configuration.
The interaction system uses trigger-based detection where each NPC maintains a circular collider zone around itself. When the player character enters this zone, an interaction prompt appears on screen indicating the ability to initiate conversation. Pressing the designated talk key (F by default) fires an interaction event that the NPC controller receives, triggering the state transition to Talk mode. The Dialog Manager then takes over, displaying conversation text, managing choice button inputs, and processing branching logic. This separation of concerns allows NPC controllers to focus purely on physical behavior and interaction detection while avoiding complex conversation logic to the specialized Dialog Manager system.
D.	Combat and Weapons
1)	Weapon system architecture
The weapon system employs a data-driven design where all weapon attributes exist as Scriptable Object assets independent of code logic. Each weapon asset defines its visual appearance, damage values, attack speed, knockback force, stun duration, and special properties such as projectile piercing. This separation allows rapid iteration on weapon balance without code recompilation and enables designers without programming knowledge to create weapon variations through Unity's inspector interface.
 
Two primary weapon archetypes implement distinct combat mechanics. Melee weapons activate a collision zone during the attack animation window, dealing damage to any enemy contacting the hitbox during that period. The weapon sprite rotates to the player's facing direction, and a slight forward thrust at final move in the combo to extend attack reach. Each swing registers damage only once per enemy regardless of hitbox contact duration, preventing multi-hit exploits. Ranged weapons spawn projectile game objects that travel in straight trajectories at constant velocity. Upon collision with enemy entities, projectiles apply damage and decrement their pierce count. Projectiles with remaining pierce count continue through enemies, while depleted projectiles destroy themselves after X seconds. Advanced projectile variants implement homing behavior after traveling a minimum distance, curving toward the nearest target within detection range.
When any weapon successfully strikes an enemy, a standardized damage sequence executes to ensure consistent combat feel. The system calculates effective damage by subtracting enemy armor from weapon attack power. It then applies this damage value to the enemy health component. If the attacking character possesses life steal, they receive healing equal to the damage dealt multiplied by life steal percentage. The struck enemy experiences knockback force pushing them away from the attacker in the impact direction. Finally, the enemy enters a stunned state for the weapon's configured stun duration, temporarily preventing movement and attacks. This execution order ensures life steal calculations use post-mitigation damage values rather than raw attack power.
2)	Combo system implementation
The combat system features a three-stage combo chain that rewards timing. Pressing the attack button initiates the first attack animation, which deals base weapon damage and opens a brief input window during the animation's recovery frames. If the player presses attack again during this window, the attack queues and automatically executes upon the current attack's completion, transitioning into the second combo stage. Each stage uses a distinct animation with progressively increasing damage multipliers.
Combo continuation requires precise timing - pressing attack too early before the input window opens has no effect, while waiting too long after the window closes resets the combo to stage one. Players can intentionally cancel combo sequences by executing a dodge roll, which immediately interrupts the attack state and transitions to the dodge state. This mechanic creates strategic decision points where players must weigh completing high-damage combos against dodging incoming enemy attacks. The combo count resets to stage one after the third attack completes, after successful dodge cancellation, or after the input window expires without additional input.
3)	Character progression and skill trees
The skill tree system provides permanent character upgrades through a prerequisite-gated progression structure. Each skill node defines a maximum level, skill point cost per level, prerequisite skill requirements, and stat effects applied upon unlocking. Skills occupy nodes in a tree visualization where connecting lines indicate prerequisite relationships. Players acquire skill points through character level advancement, with each level up awarding a X number of points for allocation.
Skill nodes exist in one of three states based on progression. Locked skills display grayed visuals with lock icons and cannot be purchased until all prerequisite skills reach maximum level. Available skills show full-color visuals and can be purchased if the player possesses sufficient skill points. The user interface updates dynamically as players invest points, recalculating which skills become available based on newly maxed prerequisites.
Skills provide passive effects that apply permanent stat modifications to enhance player capabilities. These passive skills increase base statistics such as maximum health by a fixed amount per level or add flat damage to all attacks. Additionally, the skill tree includes specialized nodes that improve weapon-specific statistics, such as slash arc angle, attack speed, movement penalty reduction, stun time bonus, and thrust distance bonus. The skill tree's prerequisite structure guides players toward building foundational improvements before accessing powerful high-tier upgrades, creating a sense of character growth and specialization over the play session.
E.	Inventory and Economy Systems
1)	Inventory management
The inventory system implements a nine-slot grid interface where each slot accommodates either stackable consumable items or single equipment pieces. Consumable items such as healing potions and food utilize stack mechanics, allowing multiple units of identical items to occupy a single slot up to a configurable maximum limit. Equipment items including weapons do not stack, with each weapon requiring dedicated slot allocation. Players interact with inventory through mouse-based drag-and-drop operations or numerical hotkey bindings mapped to slots one through nine for rapid combat access.
 
Item acquisition follows an automated management sequence. When the player collects a new item, the system first searches existing inventory slots for matching item types with available stack capacity. If a compatible stack exists, the new item increments that stack's quantity. Otherwise, the system locates the first empty slot and creates a new stack. If all slots contain items at maximum capacity, the system rejects the pickup. This automatic organization reduces manual inventory management overhead during exploration and combat scenarios.
Item consumption decrements stack quantities while applying the item's configured effects. Healing consumables restore health points, while buff items apply temporary stat modifications through the stat effect system described previously. When a stack's quantity reaches zero, the slot clears and becomes available for new items. Weapon equipping implements a swapping mechanic where selecting a weapon from inventory unequips the currently held weapon and places it in the selected inventory slot, then equips the newly selected weapon. This prevents weapon loss during equipment changes and maintains total inventory consistency.
The hot bar provides combat-optimized item access without menu navigation. Pressing numerical keys one through nine directly triggers use or equip actions for the corresponding inventory slot. During intense combat encounters, players rely heavily on hot bar bindings to consume healing items or switch weapons without interrupting movement and combat awareness by opening full inventory menus.
2)	Loot distribution system
Enemy defeat triggers probabilistic loot generation based on configured drop rates and item tables. Upon death, each enemy rolls a random value between zero and one hundred, comparing this roll against its drop chance percentage. Successful rolls select a random entry from the enemy's configured loot table and spawn a pickup object at the enemy's death position with slight random offset to prevent exact overlap when multiple enemies die simultaneously.
Loot pickup objects implement trigger zone detection, automatically collecting themselves when player contact occurs. Consumable items announce their collection through the event system, prompting the inventory manager to add the item and trigger visual and audio feedback. Weapon pickups follow identical mechanics, adding the weapon to the first available inventory. Gold drops bypass inventory slot requirements entirely, directly incrementing the player's currency counter without limitations.
3)	Shop and trading system
Shop interfaces provide item purchasing and selling functionality through merchant NPC interactions. Initiating conversation with designated merchant characters opens the shop user interface displaying available items with their prices. The merchant's inventory is populated from location-specific item lists stored in the SHOP_Keeper component. Selecting items in the shop panel attempts a purchase transaction that validates both sufficient gold and available inventory space before executing. Successful purchases deduct the item's cost from gold reserves, add the item to inventory, and provide audiovisual confirmation. Failed purchases display contextual error messages indicating insufficient gold or inventory capacity limitations.
 
Item selling follows a direct transaction mechanism where players transfer items from their inventory slots to the merchant for gold compensation. Sell prices use the same value as purchase prices, creating a risk-free buying and selling economy that encourages experimentation with different equipment and consumables. Different merchant NPCs maintain distinct inventory tables based on their location and role. Town merchants offer basic consumables and entry-level equipment, while specialized vendors in remote locations provide rare items and powerful weapons. This distribution encourages world exploration to locate optimal shopping opportunities for specific player needs.
F.	Dialog and narrative systems
The dialog system facilitates player interaction with non-playable characters through conversation interfaces supporting both linear narrative delivery and branching choice-driven conversations. When players approach NPCs designated with interaction markers and press the configured talk key, the system transitions from gameplay to conversation mode. This transition disables player movement controls, activates the dialog user interface overlay, and transfers control to the dialog manager component.
 
Dialog content structures as sequences of text lines associated with speaker metadata. Each line displays the speaking NPC's name, portrait icon, and dialog text in the conversation panel. Players advance through linear dialog sequences using mouse clicks, progressing to each subsequent line until the conversation concludes. Branching conversations extend this foundation by presenting multiple response options at decision points. The interface displays up to three choice buttons with distinct text options. Selecting different choices routes the conversation through different dialog branches, potentially leading to alternative outcomes, rewards, or follow-up conversations.
The system maintains persistent conversation state through history tracking components that record which NPCs the player has conversed with and which locations have been visited. This persistence enables conditional dialog that varies based on prior interactions. For example, an NPC might offer a quest during the first conversation, acknowledge quest completion during subsequent interactions, and provide different dialog after the quest concludes. One-time important conversations utilize completion flags preventing repetition of major story moments.
Automatic reward distribution integrates with conversation conclusions, granting items, weapons, or currency directly to the player without requiring separate interaction. When conversations containing reward definitions complete successfully, the dialog manager invokes the inventory system's add item methods. This streamlined approach eliminates the manual claim interactions common in many RPGs, maintaining narrative momentum after conversation-based quest resolutions.
G.	User Interface Systems
The user interface provides continuous player feedback through multiple specialized subsystems that maintain game state awareness without obscuring gameplay visibility. All UI elements utilize event-driven updates that respond to state changes rather than polling every frame, optimizing performance while ensuring timely visual feedback.
The introduction interface appears at game start, pausing gameplay while presenting difficulty selection through two buttons. The normal difficulty option starts the game with standard parameters, while the easy difficulty option applies bonus stat modifiers to the player's experience system and inventory before beginning gameplay. Upon selection, the interface resumes time scale, disables interaction blocking, and removes itself from the scene to prevent interference with subsequent gameplay.
The heads-up display occupies the top-left screen corner, presenting health and mana as horizontal fill bars with accompanying numerical readouts. Health displays as a green bar showing current hit points over maximum capacity, while mana appears as a blue bar representing available magical resources. These bars subscribe to health and mana change events, updating their fill percentage and text labels only when actual value changes occur. This approach prevents unnecessary recalculations while maintaining responsive visual feedback during combat damage and resource consumption.
 
The experience progression display resides below the health and mana bars in the upper-left corner, showing current level and experience progress toward the next level threshold as a yellow fill bar. The system utilizes a slider component that subscribes to experience change and level-up events from the player experience system. When experience is gained through enemy defeats, the slider value updates to reflect progress within the current level range, resetting to zero upon level advancement while incrementing the displayed level number. Debug functionality allows testing experience gain through hotkey input when development tools are enabled.
The weapon display system maintains two separate UI panels for melee and ranged weapon slots, each subscribing to weapon change events broadcast by the player controller. When weapon equipment changes occur through inventory interactions or hot bar switches, the appropriate panel receives the new weapon data and updates its image sprite to match the equipped weapon's visual representation. This dual-panel architecture allows simultaneous display of both weapon types, providing players with immediate awareness of their current combat loadout without requiring menu navigation.
The character statistics panel activates through dedicated hotkey input and UI button, overlaying the gameplay view with a comprehensive attribute listing. This panel displays all character statistics including offensive capabilities, defensive values, and mobility characteristics. The panel implementation pauses gameplay during display, allowing players to examine statistics without combat pressure. All displayed values derive from the centralized stats system described previously, ensuring consistency between displayed information and actual gameplay values. The panel updates immediately when stat-modifying events occur, reflecting equipment changes, buff applications, or skill tree upgrades in real-time.
The skill tree interface visualizes character progression through node-and-connector tree layouts. Each skill node presents its icon, name, current level progress, maximum level capacity, and skill point cost. Visual styling differentiates between locked skills awaiting prerequisite completion, available skills ready for purchase, and maximized skills Available skill point totals display prominently, updating immediately as players allocate points to skills.
 
The ending interface displays upon game completion, showing either victory or defeat messaging based on final boss death or player death respectively. The system pauses gameplay while presenting final statistics including player level, total experience earned, enemy kills, and playtime formatted as hours, minutes, and seconds. The victory condition triggers immediately upon boss defeat without delay, while the game over condition is managed by the game manager's death sequence handler. A restart button allows players to replay the session, resetting to the initial game state.
H.	Scene Transitions and Persistent State Management
Level transitions implement a fade-based sequence that smoothly moves players between game areas while maintaining state consistency. When players enter designated transition zones such as doorways or level boundaries, the system initiates a fade-to-black screen overlay with a duration of approximately half a second. During this fade transition, player input controls disable to prevent unintended movement during the loading process. The system then loads the target scene in the background while the screen remains black. Upon completion, the player character spawns at the designated spawn point position within the new level. Finally, the screen fades back to full visibility over half a second while re-enabling player controls. All character attributes, inventory contents, equipped weapons, and progression data persist across these transitions, maintaining gameplay continuity throughout the experience.
The architecture employs persistent manager objects that survive scene transitions through Unity's DontDestroyOnLoad mechanism. The Game Manager provides centralized access to other manager systems and orchestrates high-level game logic including player death handling and scene flow control. The Sound Manager maintains audio source pools for sound effects and manages background music playback, ensuring smooth audio continuity across scene boundaries. The player character object persists with all attached components including inventory data, statistical values, and progression states. The UI canvas hierarchy remains persistent to maintain interface state across transitions, preventing menu closures or setting losses during level changes.
This persistence implementation utilizes a singleton pattern where each manager checks for existing instances during initialization. If no instance exists, the manager designates itself as the singleton and marks itself for persistence. If an instance already exists when a new scene loads a duplicate manager prefab, the duplicate immediately destroys itself, preserving the original persistent instance. This approach prevents manager duplication bugs while allowing scene prefabs to include manager references for standalone testing capabilities.
Camera confinement ensures the viewport remains within playable boundaries without exposing empty space beyond tile map edges. Each scene contains an invisible polygon collider defining valid camera positions. The camera system samples this confiner geometry to constrain its position, smoothly damping toward the player character while respecting boundary limitations. This approach accommodates arbitrary level shapes beyond simple rectangles and automatically adapts to each scene's layout without manual configuration per scene. The confiner updates immediately upon scene load, preventing temporary camera drift during spawn-in sequences.
I.	Environmental Interaction Systems
Environmental objects enrich the game world by introducing interactive elements that expand traversal options, create hazards, and gate progression. These systems integrate with existing character controllers and health components through shared interfaces and event notifications.
Ladder mechanics provide vertical traversal capabilities in multi-level environments. When the player character enters a ladder trigger zone, the system modifies movement behavior to enable vertical climbing along predefined paths. The implementation applies configurable speed multipliers to both vertical and horizontal movement during ladder traversal, allowing designers to tune climbing feel independently from ground movement. Players can mount ladders from bottom or top entry points and dismount at either end or by jumping away from the ladder surface. The ladder component communicates entry and exit events to the player controller through dedicated methods, ensuring smooth state transitions between ground movement and climbing behaviors.
Gate objects implement progression barriers tied to boss encounter completion. Each gate links to a specific boss entity through inspector references. The gate monitors the linked boss's health component for death notifications through event subscription. Upon receiving the boss death event, the gate triggers a destruction sequence featuring visual effects, audio feedback, and collision removal. This design creates clear cause-and-effect relationships where defeating bosses immediately opens previously blocked pathways, providing tangible rewards for overcoming challenging encounters and naturally guiding players through intended progression sequences.
Trap systems create environmental hazards that punish careless navigation while rewarding attentive players. Damage traps implement trigger zones that apply fixed damage values to any character entering their boundaries. Unlike weapon damage that calculates armor mitigation, environmental trap damage bypasses defensive statistics to maintain consistent threat levels regardless of character progression. Trap components enforce cooldown periods between damage applications preventing rapid repeated hits that could instantly defeat players. Visual and audio indicators telegraph trap locations, allowing skilled players to navigate hazardous areas through careful positioning and timing.
 
Destructible objects add interactivity to level environments through breakable props that respond to weapon impacts. Each destructible object possesses configurable health values and subscribes to damage events similar to character entities. When accumulated damage exceeds the object's health threshold, destruction sequences activate including particle effects, sound effects, and prop removal. Some destructibles conceal rewards including consumable items, weapons, or gold pickups that spawn upon destruction. This mechanic encourages exploration and rewards players for investigating suspicious environmental elements, occasionally revealing hidden shortcuts or valuable resources behind destructible barriers.
Drowning zones enforce strict boundaries on traversal by implementing instant-kill volumes in water regions and bottomless pits. These trigger zones detect player entry and immediately invoke the health component's kill functionality, triggering standard death sequences without damage calculation delays. Visual design clearly distinguishes deadly water from safe ground through color differentiation and animation effects, providing fair warning to players about environmental dangers.
IV.	RESULT AND DISCUSSION
A.	Development Outcomes
Ninja Adventure successfully demonstrates a complete 2D action RPG implementation with all planned core systems functional. Development spanned approximately twelve weeks following an iterative milestone approach. The final build includes three playable levels with distinct environments, multiple enemy types with varying AI behaviors, three boss encounters featuring specialized mechanics, a comprehensive weapon system supporting both melee and ranged combat, an inventory management system with shopping functionality, character progression through experience and skill trees, and dialog interactions with non-playable characters.
B.	Limitations and Future Improvements
While Ninja Adventure successfully implements its core gameplay systems, several features remain unimplemented that would enhance the experience in future development iterations. The current implementation lacks a formal quest system, resulting in linear level progression from one boss encounter to the next without optional objectives or player choice in activity ordering. A comprehensive quest system would introduce a quest log interface tracking active objectives, NPC quest givers with specific completion goals, reward distribution upon quest completion, and optional side content providing additional character development opportunities.
Ultimate abilities exist in design documentation but have not received implementation, representing a significant progression system gap. These planned abilities would function as powerful active skills with extended cooldown periods, featuring special visual effects and unlock mechanisms through quest completion or rare item acquisition. 
The absence of a save and load system forces players to complete the game in single sessions, as closing the application resets all progress including inventory contents, equipment configurations, character levels, skill investments, and NPC conversation history.
Tutorial implementation remains basic, relying on players to discover mechanics through experimentation. A dedicated tutorial level with progressive instruction sequences, contextual tooltip popups explaining new mechanics, practice areas featuring invulnerable training dummies, and gradual system introduction pacing would improve new player onboarding substantially. Boss variety could expand beyond the current three encounters to include ranged bosses executing projectile patterns, swarm bosses emphasizing minion management mechanics, puzzle bosses requiring environmental interaction for vulnerability phases, and multi-phase encounters featuring arena transformation between phases.
V.	CONCLUSION
Ninja Adventure successfully demonstrates the development of a complete 2D action role-playing game using Unity engine and contemporary game development techniques. The twelve-week development cycle produced a fully playable experience featuring responsive combat mechanics, intelligent enemy artificial intelligence, character progression systems, inventory management, narrative dialog interactions, and three distinct boss encounters with specialized mechanics.
The project achieved significant technical accomplishments through architectural decisions that prioritized modularity and maintainability. The controller-state pattern provides a flexible foundation supporting players, enemies, bosses, and non-playable characters using shared code infrastructure, enabling rapid enemy type prototyping without extensive refactoring. Event-driven communication architecture eliminates tight system coupling while maintaining clean integration points for debugging and feature additions. Data-driven design through Scriptable Object assets enables rapid balance iteration, allowing gameplay value adjustments without code recompilation cycles. Time-based animation synchronization delivers reliable attack timing across all character types, while efficient performance optimization maintains stable frames per second execution with minimal load times.
From a gameplay perspective, the implementation delivers responsive combat featuring combo chains, dodge mechanics with invincibility frames, and comprehensive visual feedback systems. Enemy AI demonstrates competent detection, pursuit, and attack sequencing behaviors that create engaging encounters. Three unique boss designs present learnable attack patterns with distinct mechanical challenges and phase transitions requiring player adaptation. Complete progression systems encompassing experience point accumulation, level advancement, and skill tree customization provide meaningful character development. Functional inventory interfaces, economic shopping systems, dialog conversation trees, and smooth level transitions with persistent game state management round out the feature set.
The development process yielded valuable insights applicable to future projects. Investing in solid architectural foundations produces substantial returns - the modular state system enabled new enemy additions without legacy code disruption, event-driven design simplified debugging workflows, and asset-based data storage reduced balance iteration times from hours to seconds. Visual and audio feedback elements contribute disproportionately to perceived quality relative to implementation cost, with effects, color flash overlays, and impact sounds substantially enhancing player experience beyond technical polish. Boss encounter design benefits enormously from clear attack telegraphing through wind-up animations and audio cues, transforming potentially frustrating difficulty into fair challenges that players appreciate and learn to overcome through practice.
The established systems provide robust foundations for future expansion. Quest system architecture and ultimate ability designs with detailed specifications remain ready for development. Save and load functionality can integrate straightforwardly with existing data structures. The codebase maintains organization, documentation, and modularity supporting continued feature additions without architectural debt accumulation.
For students and aspiring developers pursuing similar 2D action RPG projects, Ninja Adventure demonstrates achievable scope through disciplined planning, modular system design, and iterative development methodologies. Beginning with core movement and combat mechanics, progressively adding individual systems, maintaining frequent testing cycles, and incorporating feedback produces complete, polished results. The experience confirms that comprehensive game projects remain within reach given appropriate planning, consistent effort, and architectural mindfulness.
ACKNOWLEDGMENT
The author would like to thank Dr. Ling Xu from the University of Houston-Downtown for her invaluable guidance and support throughout the development of this project. Her expertise and mentorship were instrumental in shaping the technical approach and ensuring the successful completion of Ninja Adventure.
REFERENCES
[1]	Unity Technologies, "Unity Real-Time Development Platform," 2025. [Online]. Available: https://unity.com/
[2]	C. Guérin, "LDtk (Level Designer Toolkit) - 2D Level Editor," 2025. [Online]. Available: https://ldtk.io/
[3]	Pixel-Boy and AAA, "Ninja Adventure Asset Pack," itch.io, 2025. [Online]. Available: https://pixel-boy.itch.io/ninja-adventure-asset-pack
[4]	Stealthix, "Animated Traps," itch.io, 2025. [Online]. Available: https://stealthix.itch.io/animated-traps
[5]	Matt (Night Run Studio), "Let's Make An Action RPG in Unity!" YouTube Playlist, 2025. [Online]. Available: https://www.youtube.com/watch?v=ZfTU67ZIK3Q&list=PLSR2vNOypvs5yLsbqZc0e6RdqNnP1eGIc
[6]	LibreSprite Contributors, "LibreSprite - Animated Sprite Editor & Pixel Art Tool," GitHub, 2025. [Online]. Available: https://libresprite.github.io/
[7]	Microsoft, "Visual Studio Code - Code Editing. Redefined," 2025. [Online]. Available: https://code.visualstudio.com/
[8]	Git, "Git - Distributed Version Control System," 2025. [Online]. Available: https://git-scm.com/ 