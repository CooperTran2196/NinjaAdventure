Development of a 2D Top-Down Action RPG in Unity

Cuong Tran
Computer Science Department
Texas Christian University
Fort Worth, Texas, USA

================================================================================

ABSTRACT

This paper presents the comprehensive design and implementation of NinjaAdventure, a 2D top-down action role-playing game (RPG) developed in Unity. The project demonstrates modern game development practices through the integration of advanced systems including state-driven character controllers, modular artificial intelligence, sophisticated inventory and loot management, branching dialog, skill progression trees, and ultimate ability systems. The architecture emphasizes clean separation of concerns, modularity, and maintainability while delivering responsive real-time combat and engaging player progression. This work documents the complete development process from initial system design through implementation, testing, and optimization, providing detailed technical insights into each major system. The project serves as both a practical demonstration of industry-standard game development patterns and a comprehensive educational reference for students and developers interested in creating complex 2D games with Unity.

Keywords: 2D Game Development, Unity Engine, Top-Down RPG, Game Architecture, Artificial Intelligence, State Machine Pattern, Controller Pattern, Inventory System, Skill Tree, Combat System, LDtk Level Design

================================================================================

I. INTRODUCTION

A. Background and Motivation

The 2D action role-playing game (RPG) genre has maintained enduring popularity in the video game industry, offering players immersive worlds, strategic combat encounters, and meaningful character progression systems. Classic titles in this genre established fundamental design patterns that continue to influence modern game development. With the accessibility and power of contemporary game engines like Unity, independent developers and small teams can now create feature-rich games with production quality previously limited to large studios.

NinjaAdventure represents a complete 2D action RPG built from the ground up using Unity 2023, demonstrating the implementation of professional-grade systems and architecture patterns. The project integrates real-time combat mechanics, enemy artificial intelligence with state-driven behaviors, comprehensive inventory and equipment management, character progression through skill trees, branching dialog systems, and multiple boss encounters with unique mechanics. The development process spanned approximately twelve weeks, progressing through iterative refinement cycles that gradually built complexity while maintaining code quality and system stability.

B. Project Objectives

The primary objective of this project was to create a complete, playable 2D action RPG that demonstrates mastery of modern game development practices and Unity-specific techniques. Specific goals included:

1. Implementing a robust, extensible controller and state machine architecture that can handle player input, enemy AI, and NPC behaviors through a unified interface
2. Creating responsive, satisfying combat mechanics with both melee and ranged weapons, incorporating combo systems, dodge mechanics with invincibility frames, and dynamic aiming
3. Developing modular AI systems for enemies and bosses that support varying complexity levels, from simple chase-and-attack patterns to multi-phase boss behaviors with special attacks
4. Building comprehensive progression systems including experience gain, leveling, skill trees with prerequisite unlocking, and stat modification
5. Implementing inventory management with drag-and-drop functionality, item stacking, equipment swapping, and integration with a shop system
6. Designing intuitive user interfaces for all systems that provide clear feedback and maintain visual consistency
7. Creating smooth scene transitions with proper data persistence across level changes
8. Establishing a complete audio system with context-appropriate sound effects and background music

C. Paper Organization

This paper is organized as follows: Section II reviews relevant literature and existing work in 2D game development and Unity-based RPG systems. Section III describes the overall game design philosophy and architectural decisions. Section IV provides detailed technical documentation of each major system implementation, including code structure and design patterns. Section V presents development results, performance analysis, and design reflections. Section VI discusses current limitations and outlines planned future enhancements. Section VII concludes with lessons learned and final observations.

================================================================================

II. LITERATURE REVIEW

The development of 2D action RPGs using Unity builds upon established research in game design patterns, artificial intelligence for games, and user interface design. Several key areas of prior work informed the design decisions for NinjaAdventure.

A. Game Architecture Patterns

Game architecture design has evolved significantly with the increasing complexity of modern games. The Model-View-Controller (MVC) pattern and its variations have become fundamental to organizing game code. The Entity-Component-System (ECS) architecture, popularized by Unity's GameObject-Component model, provides flexibility and modularity by separating data from behavior. For NinjaAdventure, a controller-state pattern was adopted, where controllers manage state transitions and physics, while individual state scripts handle specific behaviors. This pattern is documented in "Game Programming Patterns" and has been successfully applied in numerous commercial Unity projects.

The state machine pattern, particularly Finite State Machines (FSM), provides a robust foundation for managing game entity behaviors. Research in "Development of a 2D Game using Artificial Intelligence in Unity" demonstrates the application of FSM for enemy AI in Unity-based 2D games, showing clear benefits in code organization and behavior predictability. NinjaAdventure extends this approach by implementing a hierarchical state system where player, enemy, and boss controllers share a common interface but maintain specialized state implementations.

B. Combat System Design

Combat mechanics in action RPGs require careful balancing between player agency, challenge, and satisfaction. The implementation of combo systems, as seen in various action games, provides depth while maintaining accessibility. Research on animation-driven combat emphasizes the importance of tight coupling between animation events and gameplay mechanics. NinjaAdventure implements this through Unity's Animation Event system, where weapon activation and damage application are precisely timed with animation frames.

Invincibility frames (i-frames) during dodge actions are a well-established mechanic for giving players defensive options without trivializing combat. The implementation requires careful tuning of dodge distance, speed, cooldown, and i-frame duration to maintain balance. The afterimage visual effect during dodges, implemented through sprite pooling and fade coroutines, provides clear visual feedback that enhances player understanding of game mechanics.

C. Inventory and Loot Systems

Inventory management systems in RPGs must balance complexity with usability. "Infinite Loot Box: A Platform for Simulating Video Game Loot Boxes" explores the psychology and implementation of loot and reward systems in games. While NinjaAdventure does not implement loot boxes specifically, it adopts similar principles for random drop tables and rarity systems. The unified slot architecture supporting both items and weapons reduces UI complexity while maintaining functionality.

The drag-and-drop inventory interface has become standard in PC games, requiring implementation of Unity's event interfaces (IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler). The hotbar quick-access system, mapped to number keys 1-9, provides experienced players with rapid item usage while remaining accessible to newcomers through mouse interaction.

D. Skill Tree and Progression Systems

Character progression through skill trees creates meaningful player choice and customization. Research on skill tree design emphasizes the importance of prerequisite systems that create logical progression paths while preventing overwhelming choice at early levels. NinjaAdventure implements a prerequisite-based skill tree where nodes become unlockable only when all parent skills reach maximum level, ensuring players build foundational abilities before accessing advanced options.

The integration of passive stat bonuses (permanent modifications) and active abilities (ultimate skills with cooldowns) provides variety in player builds. The stat effect system, supporting duration-based modifiers (instant, permanent, and timed effects), allows for flexible implementation of items, skills, and temporary buffs through a unified code path.

E. NPC and Dialog Systems

Non-playable character (NPC) systems in RPGs serve multiple purposes: quest giving, exposition delivery, and world-building. Dialog systems range from simple linear conversations to complex branching narratives with conditional logic. NinjaAdventure implements a ScriptableObject-based dialog system that supports branching through player choice buttons, conditional display based on dialog history, and automatic reward granting upon conversation completion.

The state-based NPC behavior system allows NPCs to transition between idle, wander, and talk states seamlessly, creating believable ambient life while remaining responsive to player interaction. This approach is documented in research on believable NPC behaviors in games, emphasizing the importance of smooth transitions and appropriate context-aware responses.

F. Boss Design and AI

Boss encounters in action games require unique mechanics that distinguish them from regular enemies while remaining fair and learnable. Multi-phase boss fights, where behavior changes based on health thresholds, maintain engagement throughout prolonged encounters. NinjaAdventure implements three distinct boss types: a charger with AoE jump attacks (Giant Raccoon), a melee specialist with double-hit dash combos (Giant Red Samurai), and a summoner with phase-based retreat mechanics (Giant Summoner).

Research on game AI emphasizes the importance of readable behaviors where players can learn patterns through observation and repetition. The implementation of telegraph animations before attacks, clear audio-visual feedback, and consistent timing windows allows players to develop mastery through practice rather than memorization of arbitrary patterns.

================================================================================

III. GAME DESIGN AND ARCHITECTURE

A. Game Concept and Core Mechanics

NinjaAdventure is designed as a single-player, top-down action RPG featuring exploration, real-time combat, and character progression. The player controls a ninja character navigating through interconnected levels, defeating enemies, collecting loot, upgrading abilities, and ultimately confronting powerful bosses. The core gameplay loop consists of:

1. Combat: Engaging enemies using melee and ranged weapons with combo attacks, dodge rolls with i-frames, and special ultimate abilities
2. Exploration: Discovering new areas, interacting with NPCs, triggering dialogs, and finding secret locations
3. Progression: Gaining experience from defeated enemies, leveling up to earn skill points, and upgrading stats and abilities through the skill tree
4. Economy: Collecting gold and items, shopping at NPC vendors, managing limited inventory space, and optimizing equipment loadout
5. Story: Advancing through dialog conversations, receiving quest objectives, and experiencing narrative progression

The design philosophy emphasizes responsive controls, clear visual feedback, and meaningful player choice. Combat encounters require both strategic planning (equipment selection, skill allocation) and tactical execution (positioning, timing, resource management).

B. Architecture Overview

The project architecture follows a modular, feature-based organization where related scripts are grouped by system (Player, Enemy, Character, Weapon, Inventory, Dialog, SkillTree, UI, System, Environment). This structure facilitates code navigation and reduces coupling between systems.

[Insert Figure 1: High-level system architecture diagram showing relationships between major systems]

The core architectural pattern is a controller-state system where controllers manage state transitions and physics, while state scripts implement specific behaviors. Controllers implement a common interface (I_Controller) that provides methods for setting velocity, knockback, and stun, ensuring consistency across player, enemy, and NPC implementations.

Key architectural decisions include:

1. ScriptableObject-based data architecture: All game data (weapons, items, skills, dialogs) are stored as ScriptableObject assets, providing designer-friendly editing in the Unity Inspector and clean separation between code and content
2. Event-driven communication: Systems communicate through C# events rather than direct references, reducing coupling and improving modularity
3. Centralized managers: Singleton managers handle cross-scene concerns (GameManager, SoundManager, scene transitions) while feature-specific managers remain scoped to their systems
4. Component-based character system: Shared character components (C_Stats, C_Health, C_Mana, C_FX) are reused across player, enemies, and NPCs, reducing code duplication

C. Level Design and World Building

Levels are designed using LDtk, an open-source 2D level editor that exports tilemap data and entity placements to Unity. This workflow allows for rapid iteration on level layouts without requiring Unity Editor rebuilds. Level design follows principles of spatial clarity, enemy placement rhythm, and visual composition to guide player attention and pacing.

The game world consists of three main levels:
- Level 1 (Tutorial Zone): Introduces basic controls and mechanics with low-threat enemies and explicit instruction dialogs
- Level 2: Expands combat challenge with varied enemy types, introduces the shop system and skill tree, features the Giant Raccoon miniboss
- Level 3: Culminates in multi-phase boss encounters (Giant Summoner and Giant Red Samurai) requiring mastery of all mechanics

Scene transitions use trigger volumes that initiate fade-out effects, load target scenes asynchronously, and position the player at designated spawn points. Persistent GameObjects (marked DontDestroyOnLoad) maintain inventory, progression, and audio state across scene changes.

D. Art and Animation Pipeline

Visual assets use a consistent pixel art style sourced from asset packs, with custom modifications and additions as needed. Character sprites are organized in sprite sheets with multiple animation directions (4 or 8 directions depending on character complexity). The animation pipeline follows Unity's Animator Controller system with blend trees for directional movement and state-based transitions for actions (idle, move, attack, dodge, die).

Animation events are placed at critical frames to trigger gameplay effects:
- Attack animations fire events at the precise frame when weapon hitboxes should activate
- Footstep sounds trigger during walk cycle mid-points
- Visual effects (dust clouds, impact flashes) spawn at appropriate timing points

Visual feedback systems enhance player understanding of game state:
- Damage flash: Entities briefly tint red when taking damage
- Heal flash: Green tint indicates healing
- Afterimages: Sprite copies fade out during dodge rolls and boss dashes
- Health bars: Enemies display floating health bars that update in real-time
- Hit stop: Brief pause on impact for melee attacks (currently not implemented but planned)

================================================================================

IV. SYSTEM IMPLEMENTATION

A. Project Structure and Tools

The project is organized with the following folder structure:
- Assets/GAME/Scripts/ - All C# scripts organized by feature
  - Player/ - Player-specific controllers and states
  - Enemy/ - Enemy and boss AI scripts
  - Character/ - Shared character components (Stats, Health, Mana, FX)
  - Weapon/ - Weapon base classes and specific implementations
  - Inventory/ - Inventory, loot, and shop systems
  - Dialog/ - Dialog system and NPC interaction
  - SkillTree/ - Skill tree management and UI
  - UI/ - All UI controllers and displays
  - System/ - Global managers and scene management
  - Environment/ - Ladders, gates, traps, destructibles

Development tools and technologies:
- Unity 2023.2 (LTS) - Game engine
- C# (.NET Standard 2.1) - Programming language
- Unity Input System - Modern input handling with action maps
- LDtk 1.5.3 - Level design tool with Unity integration package
- Visual Studio 2022 - IDE with Unity integration
- Git - Version control

The Unity Input System replaces the legacy Input Manager with an asset-based configuration (P_InputActions.inputactions) that defines action maps, bindings, and control schemes. Input actions are code-generated as C# classes and instantiated at runtime, providing type-safe access to player inputs.

B. Core Systems

1) Controller and State Pattern

The controller-state pattern forms the foundation of character behavior in NinjaAdventure. This architecture separates concerns: controllers handle physics, state management, and input processing, while states implement specific behaviors.

Controller responsibilities:
- Managing Rigidbody2D physics and velocity application
- Processing inputs (player) or AI logic (enemies)
- Switching between states based on conditions
- Applying knockback and stun effects
- Handling death sequences

State responsibilities:
- Computing desired movement direction and speed
- Executing attack sequences with proper timing
- Managing animation parameters
- Communicating state changes back to controller

The player controller (P_Controller) implements a priority-based input system:
1. Death: Overrides all inputs, disables control
2. Dodge: Cancels combos, provides i-frames
3. Attack: Triggers combo or queues next attack
4. Movement: Sets velocity, updates facing
5. Idle: Default state when no input detected

States are implemented as separate MonoBehaviour components that are enabled/disabled by the controller. When a state is enabled, its OnEnable method initializes necessary values and sets animation parameters. When disabled, OnDisable cleans up (stops coroutines, resets flags). This pattern ensures states don't execute logic when inactive and prevents Update methods from running unnecessarily.

The I_Controller interface provides a unified API for external systems (weapons, effects) to interact with any controller:
```
public interface I_Controller
{
    void SetDesiredVelocity(Vector2 v);
    void SetKnockback(Vector2 kb);
    IEnumerator SetStunTime(float duration);
}
```

2) Stats, Health, and Mana Management

Character attributes are managed through three core components:

C_Stats: Stores base values and calculates final values after modifiers
- Base stats: maxHP, maxMP, attackDamage, abilityPower, armor, magicResist, moveSpeed
- Current stats: currentHP, currentMP
- Derived stats: attackSpeed, critChance, lifesteal
- Dodge stats: dodgeSpeed, dodgeDistance, dodgeCooldown
- Stat modifiers applied by items, skills, and temporary effects

C_Health: Handles damage, healing, and death
- ApplyDamage method calculates actual damage after armor/penetration
- Supports flat and percentage-based armor penetration
- Fires events: OnDamaged, OnHealed, OnDied
- Provides invincibility flag for dodge i-frames and ultimate abilities
- Kill method for instant death (used in testing and environmental hazards)

C_Mana: Manages mana consumption for abilities
- ConsumeMana method returns bool (success/fail) for validation
- Fires OnManaChanged event for UI updates
- Supports mana regeneration (currently passive, planned for active regen)

The damage calculation formula implements industry-standard armor mechanics:
```
effectiveArmor = armor * (1 - armorPenetrationPercent) - armorPenetrationFlat
damageReduction = effectiveArmor / (effectiveArmor + 100)
finalDamage = rawDamage * (1 - damageReduction)
```

This formula ensures armor provides diminishing returns (no invincibility at high armor values) while allowing penetration stats to maintain effectiveness.

3) Stats Manager and Stat Effects

The P_StatsManager serves as the centralized entry point for all stat modifications, implementing a recalculation system that ensures stat values remain synchronized across all systems.

Stat effect types:
- Instant: Applied once immediately (healing, mana restoration)
- Permanent: Added to base stats permanently (skill tree upgrades, equipment)
- Timed: Applied for duration then removed (buff/debuff items, area effects)

The recalculation flow:
1. Stat change requested (item used, skill upgraded, timer expired)
2. Manager recalculates all final stats from base + all active modifiers
3. If maxHP changed, current HP is clamped to new maximum
4. Fire OnStatsUpdated event
5. All UI elements listening to event refresh displays

This architecture prevents desynchronization bugs where different systems have conflicting views of character stats. All stat-affecting systems (inventory, skill tree, dialog rewards) route through the stats manager rather than modifying C_Stats directly.

Over-time healing (heal-over-time effects) is implemented as a timed stat effect with per-second tick logic. The manager tracks active timers and applies healing each second until the duration expires, then fires recalculation to remove the temporary maxHP boost if one was applied.

[Insert Figure 2: State machine diagram showing player states and transitions]

C. Artificial Intelligence

Enemy and boss AI systems in NinjaAdventure are built on the same controller-state foundation as the player, but with AI logic replacing input processing.

1) Regular Enemy AI

Standard enemies use a simple but effective AI system built on detection zones and state-driven behaviors:

State_Idle: Default state when no target detected
- Sets animator to idle
- No movement

State_Wander: Ambient movement for visual variety
- Picks random direction at intervals
- Walks slowly (60% of normal speed)
- Returns to idle after duration

State_Chase: Pursuit behavior when player detected
- Calculates direction to player
- Moves at full speed
- Updates facing direction for animation
- Stops at attackRange distance to maintain spacing

State_Attack: Melee or ranged attack execution
- Locks facing direction for attack duration
- Enables weapon hitbox at precise timing (animation event driven)
- Returns to Chase after attack completes
- Respects attack cooldown before next attack

Enemy AI decision logic (processed in controller Update):
```
if (player in attackRange AND facing correctly AND cooldown ready):
    TriggerAttack()
else if (player in detectionRange):
    SwitchState(Chase)
else:
    SwitchState(default wander/idle)
```

2) Boss AI Systems

Boss encounters feature specialized AI implementations that extend the base enemy pattern with unique mechanics.

Giant Raccoon (GR) - Charger Boss:
- Normal Attack: Charges at player, dashes with weapon hitbox active
- Special Attack: Jump animation followed by AoE ground pound with radial knockback
- Attack selection: Randomly chooses special when in range and cooldown ready
- Collision damage: Deals contact damage on physics collision (cooldown-gated)
- Chase pattern: Direct path to player with stopBuffer for positioning

Implementation highlights:
- Unified attack coroutine handles both normal charge and special jump
- Dash mechanics use physics prediction: dashSpeed × animationLength = dashDistance
- AoE damage uses Physics2D.OverlapCircleAll with knockback applied radially from impact point
- Afterimage system during dash provides visual clarity for player dodging

Giant Red Samurai (GRS) - Melee/Dash Boss:
- Normal Attack: Weapon-based melee strike
- Special Attack: Double-hit dash combo (first hit on dash start, second hit after brief gap)
- Y-Alignment Gate: Must be vertically aligned within threshold (yHardCap = 0.55f) to attack
- Chase pattern: Horizontal-first movement with Y-axis alignment bias
- No collision damage (final boss design choice for fairness)

The Y-alignment requirement creates tactical positioning gameplay where the boss must "set up" attacks by moving into proper alignment, telegraphing intentions and giving players reaction windows. The chase state implements a blended movement pattern:
```
if (abs(deltaY) > yAlignBand):
    prioritize vertical alignment (move mostly Y, some X)
else:
    prioritize horizontal chase (move mostly X, some Y)
```

The special attack double-hit combo uses precise timing:
1. Charge animation (0.5s delay)
2. Begin dash toward player
3. Enable weapon hitbox (first hit)
4. Continue dash for duration
5. Brief gap (0.14s)
6. Enable weapon hitbox again (second hit)
7. End attack, apply cooldown

This creates a dodge-timing challenge where players must avoid both hits or use i-frames strategically.

Giant Summoner (GS2) - Two-Phase Boss:
- Phase 1 (100% → 20% HP): Aggressive chase, periodic enemy spawning
- Phase 2 (<20% HP): Defensive retreat behavior, increased spawn frequency
- No direct attacks: Relies entirely on summoned minions
- Spawn mechanics: Circular spawn pattern around boss with outward launch velocity

Phase transition logic:
```
void CheckPhaseTransition():
    if (not phase2 yet AND currentHP <= 20% maxHP):
        trigger emergency spawn (4-5 enemies)
        set phase2 flag true
        enter retreat mode
```

Phase 2 retreat behavior:
- If player within 4 units: retreat away for 3 seconds
- After retreat: vulnerable period (2 seconds) before next retreat possible
- Creates kiting gameplay where player must capitalize on vulnerable windows

Enemy spawn implementation uses circle perimeter math:
```
for i in range(spawnCount):
    angle = (i / spawnCount) × 360°
    position = boss.position + (sin(angle), cos(angle)) × spawnRadius
    spawn enemy at position with outward velocity
```

Spawned enemies are launched with initial force (6f) to create visual impact and prevent immediate clustering.

3) NPC Behaviors

NPCs share the controller-state architecture but implement a different state set:

State_Idle: Standing still, idle animation
State_Wander: Random movement for ambient life
State_Talk: Dialog interaction with player
- Locks NPC facing toward player
- Disables movement during conversation
- Restores previous facing direction when dialog ends

NPC interaction is trigger-based: when player enters talk trigger zone, an interaction prompt appears. Pressing the talk key (F) initiates dialog through the Dialog Manager, which handles conversation flow and choice branching.

D. Combat and Skills

1) Weapon System

The weapon system is data-driven through ScriptableObjects (W_SO) that define weapon properties:
- Sprite and visual data
- Damage values (attackDamage, abilityPower)
- Attack timing (attackDuration, hitDelay)
- Special properties (knockback force, stun duration, pierce count)
- Weapon-specific settings (thrust distance for melee, projectile speed for ranged)

All weapons derive from W_Base, which provides shared functionality:
- Attack method: Activates weapon, positions sprite, enables collider
- ApplyHitEffects: Unified damage application with knockback and stun
- Polar positioning: Places weapon at angle relative to owner
- Hit tracking: Prevents multi-hit on same target per attack (melee) or respects pierce count (ranged)

Weapon specializations:

W_Melee: Close-range weapons with collider-based detection
- Attack activates collider for duration
- OnTriggerEnter2D calls ApplyHitEffects for each unique target
- Thrust mechanic: Owner moves forward slightly during attack for range extension
- Supports combo index for multi-swing patterns

W_Ranged: Projectile-based weapons
- Attack spawns projectile GameObject with velocity
- Projectile travels until hitting target or reaching max distance
- Pierce mechanic: Projectile continues through targets until pierce count exhausted
- Homing variant: Projectile curves toward nearest enemy after initial straight flight

W_ProjectileHoming: Advanced projectile with three-phase behavior
- Phase 1: Spawn fade-in (visual polish)
- Phase 2: Straight flight in spawn direction
- Phase 3: Homing toward nearest enemy with turn rate limit

The damage application order is consistent across all weapon types:
1. Calculate damage with armor/penetration
2. Apply damage to target (C_Health.ApplyDamage)
3. Calculate lifesteal healing for attacker
4. Apply knockback to target (controller.SetKnockback)
5. Apply stun to target (controller.SetStunTime)

This ordering ensures lifesteal triggers on dealt damage (not raw damage) and effects apply after damage confirmation.

2) Combo System

The player attack system supports a three-stage combo that chains attacks when timed correctly:

Combo logic (implemented in P_State_Attack):
- comboIndex: Current combo stage (0, 1, or 2)
- comboInputWindow: Time window after attack start during which next input can queue
- comboWindowTimer: Countdown timer for input window
- comboInputQueued: Flag indicating player pressed attack during window

Attack flow with combo:
1. Player presses attack → Attack state enabled, comboIndex = 0
2. Animation starts, comboWindowTimer begins countdown
3. If player presses attack while timer > 0: comboInputQueued = true
4. When attack animation completes:
   - If comboInputQueued AND comboIndex < 2: increment comboIndex, start next attack
   - Else: reset comboIndex = 0, return to previous state (move or idle)

The combo system uses Animator layers to blend attack animations smoothly, with transitions timed to match input windows. Each combo stage uses the appropriate attack animation (Attack1, Attack2, Attack3) with increasing damage multipliers.

Combo interruption: Dodge cancels combo immediately (sets comboIndex = 0, comboInputQueued = false) to prioritize defensive actions over offensive commitment.

3) Skill Tree System

The skill tree provides character progression through stat upgrades and ability unlocks. The system is built on ScriptableObject-based skill definitions (ST_SkillSO) that declare:
- Skill name and icon for UI display
- Maximum level (1 for binary unlocks, higher for scaling upgrades)
- Stat effects applied per level (list of P_StatEffect)
- Prerequisite requirements (which skills must be maxed to unlock this skill)
- Cost per level (skill points required to upgrade)

Skill types:
- Stat upgrades: Permanent bonuses to character stats (MaxHP +20, AttackDamage +5)
- Lifesteal: Percentage of damage dealt returned as healing
- Ultimate abilities: Active skills with cooldowns (planned system, documented in ULTIMATE_SKILLS_SYSTEM.md)

The ST_Manager coordinates skill tree operation:
- TryToUpgrade: Validates skill points, prerequisite completion, level cap
- ApplySkillEffects: Routes stat effects to P_StatsManager for recalculation
- HandleSkillUpgraded: Updates UI, unlocks dependent skills, deducts skill points
- HandleSkillMaxed: Enables child skills when prerequisites met

Prerequisite system:
- Each skill declares prerequisite skill references (List<ST_Slots>)
- CanUnlock checks if all prerequisites are at maxLevel
- When skill reaches maxLevel, ST_Manager traverses child skills to enable newly unlocked options

This creates a progression path where foundational skills (tier 1) must be completed before accessing advanced options (tier 2, 3), preventing overwhelming choice while maintaining build variety.

Skill points are earned through leveling (P_Exp component tracks XP and level). Each level grants configurable skill points (default: 2 points per level). The UI displays available skill points and visually indicates which skills are affordable, locked, or maxed.

[Insert Figure 3: Skill tree UI showing prerequisite connections and lock states]

E. Inventory and Loot

1) Inventory System

The inventory is implemented as a 9-slot unified system that holds both items and weapons. Each slot (INV_Slots) tracks:
- SlotType: Empty, Item, or Weapon
- itemSO: Reference to INV_ItemSO if slot contains item
- weaponSO: Reference to W_SO if slot contains weapon
- quantity: Stack count for items (weapons don't stack)

Core inventory operations:

AddItem(itemSO, quantity): Attempts to stack into existing slots first, then fills empty slots, drops overflow as loot
- Stacking logic: Find slots with same itemSO not at stackSize limit, add to those first
- New slot logic: Find first empty slot, set type = Item, initialize with itemSO and quantity
- Overflow logic: If no space available, spawn loot prefab at player position with remaining quantity

UseItem(slot): Consumes item from inventory and applies effects
- Validates slot contains item and quantity > 0
- Routes stat effects to P_StatsManager for application
- Decrements quantity, updates UI
- If quantity reaches 0, clears slot (type = Empty)

SetWeapon(slot): Equips weapon from inventory, swaps with currently equipped weapon
- Validates slot contains weapon
- Calls P_Controller.SetWeapon with weaponSO
- Returns previously equipped weapon (or null)
- Places returned weapon in inventory slot (swap logic)
- Updates UI to reflect change

DropItem/DropWeapon: Spawns loot prefab at player position
- Instantiates unified loot prefab (INV_Loot)
- Initializes with appropriate type and data
- Removes from inventory, updates UI

2) Loot System

The loot system uses a single prefab (INV_Loot) with a LootType enum (Item, Weapon, Gold) to differentiate drop types. Each loot instance is configured with appropriate ScriptableObject reference and quantity.

Loot pickup flow:
1. Player enters trigger collider on loot GameObject
2. INV_Loot fires static event: OnItemLooted(itemSO, quantity) or OnWeaponLooted(weaponSO)
3. INV_Manager listens to events, routes to AddItem or AddWeapon
4. If successfully added: play pickup sound, destroy loot GameObject
5. If inventory full: loot remains on ground for later pickup

Loot drops are triggered by enemy death (E_Reward component):
- Configurable drop chance (0-100%)
- Drop table with weighted entries (itemSO or weaponSO, quantity, weight)
- On death: roll random value, if below chance, select random entry from drop table
- Instantiate loot prefab at enemy position with slight randomized offset

Gold is handled as special case:
- Gold loot type adds directly to INV_Manager.gold without consuming inventory space
- Gold text UI updates immediately
- Gold pickup plays distinct sound effect for clear feedback

3) Shop System

The shop system enables item purchasing from NPC vendors. Key components:

SHOP_Manager: Controls shop UI and transaction logic
- PopulateShopItems: Fills shop slots with vendor's item list
- TryBuyItem: Validates gold and inventory space, processes purchase
- SellItem: Adds gold, removes item from inventory

SHOP_Keeper: NPC interaction component
- Defines location-specific item lists (different vendors sell different items)
- Opens shop UI when player enters trigger and presses interact key
- Pauses game while shop is open (Time.timeScale = 0)
- Broadcasts shop open/close events for inventory slot behavior changes

SHOP_Slot: Individual shop item display
- Shows item icon, name, and price
- Buy button triggers SHOP_Manager.TryBuyItem
- Hover displays item info popup with stat effects

Shop-inventory integration:
- When shop is open: inventory right-click sells items instead of dropping
- Inventory listens to shop open/close events to switch behavior
- Weapons cannot be sold (design decision to prevent accidental equipment loss)

The shop interface includes category filtering (Items, Weapons, Armor) though the current implementation focuses on items. The UI provides clear feedback for insufficient gold (grayed out buy button) and full inventory (warning message).

[Insert Figure 4: Shop interface showing item grid, prices, and inventory integration]

F. User Interface and Experience

1) Health/Mana and Stats UI

Character status displays are implemented as event-driven UI components that update only when underlying values change, avoiding per-frame polling.

HealthUI: Displays HP bar and numeric text
- Listens to C_Health.OnDamaged and C_Health.OnHealed events
- Updates slider value (currentHP / maxHP) and text ("{current}/{max}")
- Smooth lerp transition for bar fill (optional, currently instant for clarity)

ManaUI: Displays MP bar and numeric text
- Listens to C_Mana.OnManaChanged event
- Updates slider value (currentMP / maxMP) and text

StatsUI: Comprehensive character stat panel
- Displays all stats from C_Stats (HP, MP, AD, AP, Armor, MagicResist, MS, AS, Crit, Lifesteal)
- Listens to P_StatsManager.OnStatsUpdated event
- Toggleable with hotkey (Tab) or UI button
- Pauses game when open (Time.timeScale = 0)

The event-driven architecture ensures UI updates are synchronized with game state changes without requiring manual update calls. When P_StatsManager recalculates stats, the single OnStatsUpdated event triggers all subscribed UI elements to refresh simultaneously.

2) Inventory UI

The inventory UI implements a grid of 9 slots with drag-and-drop functionality for reorganization.

Slot interactions:
- Left-click: Use item (applies effects) or equip weapon (swaps with equipped)
- Right-click: Drop item/weapon (shop closed) or sell item (shop open)
- Hover (1 second): Display info popup with item description and stat effects
- Drag: Begin drag operation, display dragged item sprite following cursor
- Drop on slot: Swap contents with target slot
- Drop outside UI: Cancel drag, return item to original slot

The drag-and-drop system uses Unity's event interfaces:
- IBeginDragHandler: Start drag, store original slot reference, show dragged sprite
- IDragHandler: Update dragged sprite position to follow cursor
- IEndDragHandler: Complete drag, clear dragged sprite
- IDropHandler: Handle drop onto slot, swap logic

Hotbar functionality (number keys 1-9) provides quick access:
- INV_HotbarInput component listens to Input System actions (Hotbar1-9)
- Maps key presses to inventory slot indices (1 = slot 0, 2 = slot 1, etc.)
- Triggers UseItem or SetWeapon based on slot contents

Visual feedback:
- Equipped weapon highlight: Slots containing currently equipped weapons show colored border
- Empty slots: Transparent background, no icon
- Item slots: Show item icon, quantity text in corner
- Weapon slots: Show weapon icon, no quantity (weapons don't stack)

3) Dialog System

The dialog system presents conversations with NPCs through a UI panel with speaker name, dialog text, and optional choice buttons.

Dialog flow:
1. Player presses talk key (F) near NPC
2. D_Manager receives D_SO (dialog ScriptableObject) and displays first line
3. For each line: show speaker name, display text, wait for player input (Space or click)
4. If dialog has choices: display up to 3 choice buttons with text
5. Player clicks choice → loads nextDialog from selected D_Option
6. If no choices: dialog ends, close panel
7. If dialog has auto-rewards: grant items/weapons through INV_Manager

Dialog system features:
- Speaker system: D_ActorSO defines NPC name and portrait (portrait not implemented yet)
- Branching: D_Option defines choice text and next dialog node
- Conditions: Dialog can check history (D_HistoryTracker) to conditionally show/hide based on previous conversations
- Rewards: D_AutoReward automatically grants items/weapons when dialog completes
- One-time dialogs: Flag prevents dialog from repeating after first view

Dialog history tracking:
- Records which NPCs have been spoken to (by NPC GameObject name)
- Records which locations have been visited (by D_LocationSO reference)
- Provides query methods for conditional dialog checks

The dialog UI uses TextMeshPro for text rendering with rich text support (bold, italics, color tags). The panel includes close button (X) and continue indicator (blinking arrow) for clear user guidance.

4) Shop Interface

The shop UI presents a grid of purchasable items with buy buttons, hover information, and category filtering.

Shop UI elements:
- Shop slots (SHOP_Slot): Display item icon, name, price
- Buy buttons: Trigger SHOP_Manager.TryBuyItem when clicked
- Item info popup: Shows item description and effects on hover
- Category buttons: Filter shop contents by type (not fully implemented)
- Close button: Exits shop, resumes game

Purchase flow:
1. SHOP_Keeper populates shop with location-specific item list
2. Player views items and hovers for details
3. Player clicks buy button on desired item
4. SHOP_Manager validates: sufficient gold? AND inventory space available?
5. If valid: deduct gold, add item to inventory, play sound
6. If invalid: display message (insufficient gold or full inventory)

Selling flow (from inventory while shop open):
1. Player right-clicks item in inventory
2. INV_Slots checks if shop is open (listens to SHOP_Keeper events)
3. If shop open: call SHOP_Manager.SellItem instead of drop
4. Manager adds item price to gold, inventory removes item

The shop interface provides immediate visual feedback: gold display updates on purchase, inventory slots highlight when containing sellable items, and audio cues confirm transactions.

5) Skill Tree and Upgrade UI

The skill tree UI visualizes character progression options through a node-based layout with prerequisite connections.

Skill tree elements:
- Skill nodes (ST_Slots): Display skill icon, name, current level / max level
- Upgrade button: Attempts upgrade when clicked (if affordable and unlocked)
- Skill points display: Shows available points at top of panel
- Prerequisite lines: Visual connections between parent and child skills (not dynamically drawn, part of UI layout)

Skill node states:
- Locked: Prerequisites not met, grayed out, button disabled
- Unlocked but unaffordable: Prerequisites met but insufficient skill points, partially grayed
- Unlocked and affordable: Prerequisites met and points available, full color, button enabled
- Maxed: At max level, gold border, shows "MAX" instead of level

Upgrade flow:
1. Player clicks skill node button
2. ST_Manager.TryToUpgrade validates:
   - Sufficient skill points?
   - Prerequisites completed (all parent skills at max level)?
   - Not already at max level?
3. If valid:
   - Increment skill level
   - Apply stat effects through P_StatsManager
   - Deduct skill points
   - Update UI: current level, available points, unlock dependent skills
   - Play upgrade sound
4. If invalid: show message indicating reason

The skill tree updates in real-time as skills are upgraded: when a skill reaches max level, child skills unlock (lock icon removed, button enabled) if all other prerequisites are also met. This provides clear visual feedback on progression paths and encourages experimentation with different build orders.

[Insert Figure 5: Skill tree UI with locked, unlocked, and maxed states visible]

G. Scene Management and Persistence

Scene management ensures smooth transitions between levels while maintaining game state across scene changes.

1) Scene Transition System

Scene transitions use a choreographed sequence to avoid jarring cuts:

Transition flow:
1. Player enters SYS_SceneTeleport trigger volume
2. Teleporter begins fade-out (SYS_Fader.FadeOut, 0.5 seconds)
3. During fade: disable player input to prevent movement
4. When fade complete: call SceneManager.LoadScene(targetScene)
5. On scene load: player spawns at SYS_SpawnPoint with matching spawn ID
6. SYS_Fader begins fade-in (0.5 seconds)
7. Player input re-enabled, gameplay resumes

The fade effect uses a full-screen black Image component with CanvasGroup alpha lerp. During fades, the CanvasGroup blocks raycasts to prevent UI interaction.

Spawn point system:
- Each scene contains SYS_SpawnPoint GameObjects with unique IDs
- Teleporter specifies target scene and spawn ID
- On scene load, SYS_SpawnManager finds matching spawn point and positions player
- Default spawn point (ID: "Default") used if specified ID not found

This approach supports multiple entry points per scene (e.g., entering from Level 1 vs. fast travel from town).

2) Persistent Managers

Certain GameObjects must persist across scene changes to maintain game state:

Persistent objects (marked DontDestroyOnLoad):
- GameManager: Centralized access to other managers, handles player death logic
- SoundManager: Audio source pools, plays SFX and music
- Player: Character GameObject with all components, inventory, stats, progression
- Canvas (UI Root): All UI panels to maintain state

Persistence implementation:
```
void Awake()
{
    if (Instance == null)
    {
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    else
    {
        Destroy(gameObject); // Destroy duplicate from new scene
    }
}
```

This singleton pattern ensures only one instance of each manager exists. When a new scene loads containing a duplicate, the duplicate self-destructs, preserving the original persistent instance.

3) Camera Confinement

The camera follows the player but must remain within level bounds to avoid showing empty space beyond the tilemap.

Camera confinement implementation:
- Each scene contains an invisible PolygonCollider2D defining level bounds
- SYS_ConfinerFinder finds this collider on scene load
- Cinemachine Confiner extension constrains camera position to within collider bounds
- Camera smoothly damps toward player position while respecting boundaries

This system allows arbitrary level shapes (not just rectangles) and automatically adapts to each scene's layout. The confiner updates immediately on scene load, preventing any camera drift into empty areas during spawn.

================================================================================

V. RESULTS AND DISCUSSION

A. Development Results

The NinjaAdventure project successfully implements a complete, playable 2D action RPG with all planned core systems functional and integrated. Development spanned approximately twelve weeks (late August through mid-November 2024), progressing through seven major weekly milestones:

Week 2-3: Foundation (Player/Enemy movement, basic combat, stats)
Week 4: Weapon system (Free-aim, melee/ranged, combo)
Week 5: Skill tree and stat progression
Week 6: Inventory and shop systems
Week 7: NPC, dialog, scene transitions
Week 8-9: Boss AI implementations
Week 10: Audio system and polish
Week 11: Boss refinements and optimization

The final build includes:
- 3 playable levels with distinct environments and enemy configurations
- 10+ unique enemy types with varying behaviors and stats
- 3 boss encounters with specialized mechanics
- 15+ weapons (melee and ranged varieties)
- 25+ items with stat effects and consumables
- 12-node skill tree with prerequisite unlocking
- Complete UI suite for inventory, stats, shop, dialog, skill tree
- Full audio implementation with 30+ sound effects and background music
- Smooth scene transitions with persistence across levels

B. Technical Performance

Performance testing on target hardware (Intel i5-12400F, NVIDIA GTX 1660, 16GB RAM) demonstrates stable frame rates throughout gameplay:

- Average FPS: 58-60 (vsync enabled, 60 FPS target)
- Frame drops: None observed during normal gameplay
- Load times: < 1 second for scene transitions
- Memory usage: ~450 MB total, stable (no leaks detected)

The modular architecture contributes to performance stability by minimizing per-frame overhead:
- Event-driven UI updates avoid redundant recalculations
- State enable/disable pattern prevents inactive scripts from executing
- Object pooling for projectiles and afterimages reduces garbage collection pressure
- Efficient collision detection through layer-based filtering

Profiling reveals the most expensive operations are:
1. Unity's internal rendering (expected, unavoidable)
2. Physics2D collision detection (optimized via layer collision matrix)
3. Animator state machine updates (necessary for animation quality)
4. UI canvas rebuilds (minimized through event-driven updates)

No custom code appears in top performance bottlenecks, indicating efficient implementation.

C. Gameplay Experience

Informal playtesting with peers provided valuable feedback on game feel and balance:

Positive feedback:
- Combat feels responsive, dodge timing is satisfying
- Visual feedback clearly communicates damage, effects, cooldowns
- UI is intuitive, information is easy to find
- Boss patterns are learnable, difficulty is fair
- Progression through skill tree feels meaningful

Areas for improvement:
- Enemy variety could be greater (more attack patterns, behaviors)
- Level layouts feel similar, need more environmental diversity
- Some items are clearly optimal, reducing build variety
- Tutorial could be more explicit about combo timing
- Boss difficulty spikes sharply, mid-tier challenge missing

Balancing adjustments were made iteratively:
- Dodge cooldown increased (0.8s → 1.2s) to prevent spam
- Boss attack cooldowns tuned for readability (players need time to react)
- Lifesteal values reduced (was too strong, made player unkillable)
- Item prices adjusted to create meaningful economic choices

D. Design Reflections

Several key lessons emerged from the development process:

1. State machine architecture scales well: The controller-state pattern proved highly extensible. Adding new enemy types required only implementing new state behaviors, not refactoring core systems. Bosses naturally extended enemy patterns without code duplication.

2. Event-driven communication reduces coupling: Using C# events for system communication (health changes, item pickups, skill upgrades) made systems modular and easier to debug. When issues arose, the event-driven architecture made it clear which system was responsible.

3. ScriptableObjects enable rapid iteration: Storing all game data (weapons, items, skills, dialogs) as ScriptableObject assets allowed balance changes and content additions without touching code. Designers (or the solo developer wearing designer hat) can adjust values in Unity Inspector and see results immediately.

4. Animation-driven combat feels better than frame-perfect timing: Initially, weapon activation used fixed timers. Switching to animation events produced tighter coupling between visuals and mechanics, making attacks feel more responsive and eliminating sync issues.

5. UI feedback is critical for polish: Adding subtle touches (hover delays, sound effects, fade transitions) dramatically improved perceived quality. Players respond to clear visual/audio cues more than numerical accuracy.

6. Boss design benefits from clear telegraphs: Early boss iterations felt unfair because attacks happened too quickly. Adding charge-up animations and clear audio cues before attacks made patterns learnable and fair, even when difficult.

E. Code Quality and Maintainability

The project maintains high code quality standards throughout:

- Consistent naming conventions (prefix system: P_ for Player, E_ for Enemy, etc.)
- XML documentation comments on all public methods and complex logic
- RequireComponent attributes ensure component dependencies are met
- Inspector field validation with Range attributes and header labels
- Defensive programming with null checks and error logging
- Event cleanup (subscribe in OnEnable, unsubscribe in OnDisable)

The codebase consists of approximately:
- 7,500 lines of gameplay code (Player, Enemy, Character, Weapon systems)
- 4,200 lines of UI code (Inventory, Shop, Dialog, SkillTree)
- 2,800 lines of management code (System, Scene transitions, Audio)
- 1,500 lines of environment code (Ladders, Gates, Traps, Destructibles)
- Total: ~16,000 lines of C# (excluding auto-generated input actions)

Code organization follows consistent patterns:
- Fields grouped by category with [Header] attributes
- Methods ordered: Unity lifecycle → public API → private implementation
- Coroutines clearly named with Routine suffix
- Event handlers named Handle[EventName] for clarity

[Insert Figure 6: In-game screenshot showing combat encounter with UI elements visible]

================================================================================

VI. LIMITATIONS AND FUTURE WORK

A. Current Limitations

Despite comprehensive implementation of core systems, several features remain incomplete or could be improved:

1) Quest System: Currently, progression is linear (defeat boss, move to next level). A proper quest system would add:
- Quest log UI tracking active objectives
- Quest giver NPCs with repeatable tasks
- Rewards tied to quest completion
- Side quests for optional content

2) Ultimate Skills: The system architecture is designed (documented in ULTIMATE_SKILLS_SYSTEM.md) but not fully implemented. Planned features include:
- Active abilities with cooldowns (Dagger Barrage, Divine Intervention)
- Ultimate-specific UI with cooldown displays
- Unlock items obtained through quests or dialog
- Separate animation layer for ultimate effects

3) Save/Load System: Currently, game state resets on application close. A save system would persist:
- Inventory contents and equipped weapons
- Character level, skill points, and unlocked skills
- Dialog history and quest progress
- Visited locations and defeated bosses

4) Enemy Variety: Current enemies use limited behavior patterns. Additional variety could include:
- Ranged enemies that maintain distance and fire projectiles
- Support enemies that buff allies or heal
- Elite variants with enhanced stats and special attacks
- Environmental-specific enemies (flying, swimming, climbing)

5) Environmental Interaction: Current environment is mostly static. Planned additions:
- Pushable blocks for puzzle elements
- Pressure plates triggering doors or traps
- Breakable walls revealing secrets
- Interactive objects (levers, chests, signs)

B. Planned Enhancements

Future development will focus on several key areas:

1) Tutorial System Expansion:
- Dedicated tutorial level with step-by-step guidance
- Pop-up tooltips explaining mechanics on first encounter
- Practice areas with dummy enemies for combo training
- Gradual introduction of systems (combat → inventory → skills → shop)

2) Boss Encounter Variety:
- Additional boss types with unique mechanics (ranged boss, swarm boss, puzzle boss)
- Multi-phase transitions with arena changes
- Boss telegraphs and attack patterns expansion
- Optional difficulty modifiers for replay value

3) Visual Polish:
- Particle effects for ability activations
- Screen shake and hit stop on critical hits
- Weather effects and ambient animations
- Improved lighting with dynamic shadows

4) Audio Refinement:
- Context-aware music transitions (calm exploration vs. combat intensity)
- Positional audio for environmental sounds
- Voice synthesis for dialog (text-to-speech with pitch/speed variation)
- Adaptive music system responding to player health and situation

5) Accessibility Options:
- Colorblind modes for UI and effects
- Adjustable UI scaling and font sizes
- Rebindable controls with gamepad support
- Difficulty modes (health scaling, damage adjustments, cooldown modifiers)

C. Long-Term Vision

The long-term vision for NinjaAdventure includes expanding beyond the current scope:

Multiplayer Potential:
- Local co-op with drop-in/drop-out
- Shared inventory and quest progress
- Scaling enemy difficulty based on player count
- Cooperative boss encounters requiring teamwork

Procedural Generation:
- Randomized dungeon layouts for replayability
- Procedural enemy placement based on difficulty curves
- Random item drops with stat ranges
- Challenge modes with modifiers and leaderboards

Modding Support:
- Custom weapon creation tools
- Dialog editor for user-generated conversations
- Level editor based on LDtk workflow
- Script hooks for custom behaviors

These enhancements would transform NinjaAdventure from a learning project into a content-rich, replayable experience suitable for commercial release.

================================================================================

VII. CONCLUSION

The development of NinjaAdventure demonstrates the successful application of modern game development practices to create a complete 2D action RPG in Unity. The project integrates complex systems—state-driven AI, data-driven weapon mechanics, progression through skill trees, comprehensive inventory management, and branching dialog—while maintaining code quality and performance.

Key achievements include:

Technical Execution:
- Robust controller-state architecture enabling code reuse across player, enemies, bosses, and NPCs
- Event-driven communication reducing system coupling and improving maintainability
- ScriptableObject-based data architecture separating code from content
- Comprehensive UI system with drag-and-drop inventory, real-time stat displays, and clear feedback

Gameplay Design:
- Responsive combat with satisfying dodge mechanics and combo systems
- Meaningful progression through skill trees and equipment upgrades
- Engaging boss encounters with learnable patterns and fair difficulty
- Clear visual and audio feedback enhancing player understanding

Development Process:
- Iterative refinement through weekly milestones
- Consistent code organization and documentation
- Performance optimization through profiling and architecture decisions
- Regular playtesting informing balance adjustments

The project serves multiple purposes: as a portfolio piece demonstrating technical competency, as an educational resource documenting implementation details of common game systems, and as a foundation for continued development toward a commercial-quality product.

Personal reflections on the development process highlight the importance of planning architecture early, maintaining code quality throughout development, and iterating based on playtesting feedback. The modular design proved invaluable when adding new features, and the event-driven communication pattern simplified debugging complex interactions between systems.

Future developers undertaking similar projects can learn from this work: invest time in solid architecture before building features, embrace data-driven design for flexibility, and prioritize player feedback over theoretical correctness. Game development is iterative, and maintaining clean, modular code enables that iteration without technical debt accumulation.

NinjaAdventure represents approximately 300 hours of development work over twelve weeks, resulting in a playable, polished experience that demonstrates comprehensive understanding of Unity game development, C# programming, and RPG system design.

================================================================================

REFERENCES

[1] Unity Technologies. "Unity User Manual 2023.2." Unity Documentation, 2023. Available: https://docs.unity3d.com/

[2] Deepnight. "LDtk - Level Designer Toolkit." LDtk Documentation, 2023. Available: https://ldtk.io/docs/

[3] Unity Technologies. "Input System Package." Unity Documentation, 2023. Available: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/

[4] R. Nystrom. "Game Programming Patterns." Genever Benning, 2014.

[5] I. Millington and J. Funge. "Artificial Intelligence for Games," 2nd ed. CRC Press, 2009.

[6] S. Rabin, ed. "Game AI Pro: Collected Wisdom of Game AI Professionals." CRC Press, 2013.

[7] E. Lengyel. "Foundations of Game Engine Development, Volume 1: Mathematics." Terathon Software LLC, 2016.

[8] J. Gregory. "Game Engine Architecture," 3rd ed. CRC Press, 2018.

[9] T. Akenine-Möller, E. Haines, and N. Hoffman. "Real-Time Rendering," 4th ed. CRC Press, 2018.

[10] Unity Technologies. "Unity Best Practices." Unity Learn, 2023. Available: https://learn.unity.com/

[11] Microsoft. "C# Programming Guide." Microsoft Docs, 2023. Available: https://docs.microsoft.com/en-us/dotnet/csharp/

[12] S. McConnell. "Code Complete," 2nd ed. Microsoft Press, 2004.

================================================================================

FIGURE CAPTIONS

[Figure 1: High-level system architecture diagram showing relationships between major systems]
- Place near Section III.B (Architecture Overview)
- Should show: Player/Enemy/NPC Controllers, State Scripts, Character Components (Stats/Health/Mana), Weapon System, Inventory/Shop, Dialog, Skill Tree, UI, Managers

[Figure 2: State machine diagram showing player states and transitions]
- Place near Section IV.B.1 (Controller and State Pattern)
- Should show: Idle, Movement, Attack, Dodge, Death states with transition arrows and priority labels

[Figure 3: Skill tree UI showing prerequisite connections and lock states]
- Place near Section IV.D.3 (Skill Tree System)
- Should show: Multiple skill nodes in locked, unlocked, and maxed states, with visible prerequisite connections

[Figure 4: Shop interface showing item grid, prices, and inventory integration]
- Place near Section IV.E.3 (Shop System)
- Should show: Shop slots with items, buy buttons, prices, and visible inventory panel for selling

[Figure 5: Skill tree UI with locked, unlocked, and maxed states visible]
- Place near Section IV.F.5 (Skill Tree and Upgrade UI)
- Should show: Detailed view of skill nodes with different states, skill points display, and upgrade feedback

[Figure 6: In-game screenshot showing combat encounter with UI elements visible]
- Place near Section V.E (Code Quality and Maintainability) or Results section
- Should show: Player fighting enemies or boss, with health bars, inventory hotbar, and skill cooldowns visible

[Additional figures as needed for LDtk level design, weapon system diagrams, AI flowcharts, etc.]

================================================================================

WORD COUNT: ~8,150 words (excluding references and figure captions)

================================================================================
