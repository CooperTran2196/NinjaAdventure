// ----- File: INV_ItemSO.cs -----
using UnityEngine;

[CreateAssetMenu(fileName = "INV_ItemSO", menuName = "INV_ItemSO")]
public class INV_ItemSO : ScriptableObject
{
    public string itemName = "Auto Filled";
    [TextArea] public string itemDescription;
    public Sprite icon;

    [Header("Flags")]
    public bool isGold;

    [Header("Stats (delta)")]
    public int currentHealth; // heal amount (0 = none)
    public int maxHealth;     // permanent max HP change (0 = none)
    public int speed;         // movement speed delta
    public int damage;        // basic damage delta
    public int stackSize = 3;

    [Header("Temporary")]
    public float durationSec; // 0 = permanent effect

    private void OnValidate()
    {
        if (itemName != name)
            itemName = name;
    }
}

// ----- File: INV_Loot.cs -----
using System;
using UnityEngine;

[ExecuteAlways] // lets OnEnable/Update run in edit mode too
public class INV_Loot : MonoBehaviour
{
    public static event Action<INV_ItemSO, int> OnItemLooted;

    [Header("Data")]
    public INV_ItemSO item;
    public int quantity = 1;

    [Header("Refs")]
    public SpriteRenderer sr;
    public Animator animator;

    [Header("Pickup Gate")]
    public bool canBePickedUp = true;

    CircleCollider2D trigger;

    // --- NEW: queued refresh so we don't touch sprite in OnValidate ---
    bool _needsVisualRefresh;

    void Awake()
    {
        sr       ??= GetComponentInChildren<SpriteRenderer>();
        animator ??= GetComponent<Animator>();
        trigger  ??= GetComponent<CircleCollider2D>();

        if (!sr) Debug.LogError($"{name}: SpriteRenderer missing.", this);
        if (!animator) Debug.LogError($"{name}: Animator missing.", this);
        if (!trigger) Debug.LogError($"{name}: CircleCollider2D missing.", this);
    }

    // Only flag here; don't set sr.sprite inside OnValidate
    void OnValidate()
    {
        sr ??= GetComponentInChildren<SpriteRenderer>();
        _needsVisualRefresh = true;
    }

    void OnEnable()
    {
        // Also refresh on enable (covers play + edit)
        _needsVisualRefresh = true;
    }

    void Update()
    {
        if (_needsVisualRefresh)
        {
            SafeRefreshAppearance();
            _needsVisualRefresh = false;
        }
    }

    // Used by Initialize() and by our deferred refresh
    void SafeRefreshAppearance()
    {
        if (!sr) sr = GetComponentInChildren<SpriteRenderer>();
        if (item != null)
        {
            sr.sprite = item.icon;         // safe here (not inside OnValidate/Awake)
            gameObject.name = item.itemName;
        }
    }

    public void Initialize(INV_ItemSO so, int qty)
    {
        item = so;
        quantity = qty;
        canBePickedUp = false;
        _needsVisualRefresh = true; // defer sprite/name
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (!other.CompareTag("Player") && !canBePickedUp) return;

        trigger.enabled = false;
        OnItemLooted?.Invoke(item, quantity);
        animator?.SetTrigger("Pickup");
        Destroy(gameObject, 0.5f);
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (!other.CompareTag("Player")) return;
        
        canBePickedUp = true;
    }
}

// ----- File: INV_Manager.cs -----
// Assets/GAME/Scripts/INV/INV_InventoryManager.cs
using UnityEngine;
using TMPro;

public class INV_Manager : MonoBehaviour
{
    [Header("References")]
    INV_UseItem useItem;

    public TMP_Text goldText;
    public GameObject lootPrefab;
    public Transform player;
    public int gold;
    public INV_Slots[] inv_Slots;

    void OnEnable()  => INV_Loot.OnItemLooted += AddItem;
    void OnDisable() => INV_Loot.OnItemLooted -= AddItem;

    void Awake()
    {
        useItem ??= GetComponent<INV_UseItem>();
        if (!useItem) Debug.LogError($"{name}: INV_UseItem missing.", this);
    }

    void Start()
    {
        foreach (var slot in inv_Slots) slot.UpdateUI();
        UpdateGoldText();
    }

    public void AddItem(INV_ItemSO inv_ItemSO, int quantity)
    {
        if (inv_ItemSO.isGold)
        {
            gold += quantity;
            UpdateGoldText();
            return;
        }

        // Stack into existing slots of the same item
        foreach (var slot in inv_Slots) // SAME item AND room left
        {
            if (slot.item == inv_ItemSO && slot.quantity < inv_ItemSO.stackSize)
            {
                int availableSpace = inv_ItemSO.stackSize - slot.quantity;
                int amountToAdd    = Mathf.Min(availableSpace, quantity);

                slot.quantity += amountToAdd;
                quantity      -= amountToAdd;

                slot.UpdateUI();
                if (quantity <= 0) return;
            }
        }

        // Fill empty slots
        foreach (var slot in inv_Slots) // items remain -> use empty slots
        {
            if (slot.item == null)
            {
                int amountToAdd = Mathf.Min(inv_ItemSO.stackSize, quantity);

                slot.item     = inv_ItemSO;
                slot.quantity = amountToAdd;
                slot.UpdateUI();

                quantity -= amountToAdd;
                if (quantity <= 0) return;
            }
        }

        // No room -> drop overflow at player
        if (quantity > 0) DropLoot(inv_ItemSO, quantity);
    }

    void UpdateGoldText()
    {
        goldText.text = gold.ToString();
    }

    public void UseItem(INV_Slots slot)
    {
        if (slot == null || slot.item == null || slot.quantity <= 0) return;

        bool used = useItem.ApplyItemEffects(slot.item);
        if (!used) return; // Tried to heal at full HP

        slot.quantity -= 1;
        if (slot.quantity <= 0) slot.item = null;
        slot.UpdateUI();
    }

    // RIGHT-CLICK drop exactly one
    public void DropItemFromSlot(INV_Slots slot)
    {
        if (slot == null || slot.item == null || slot.quantity <= 0) return;

        DropLoot(slot.item, 1);
        slot.quantity -= 1;
        if (slot.quantity <= 0) slot.item = null;
        slot.UpdateUI();
    }

    void DropLoot(INV_ItemSO item, int qty)
    {
        if (!lootPrefab || !player) return;

        var go = Instantiate(lootPrefab, player.position, Quaternion.identity);
        var loot = go.GetComponent<INV_Loot>();
        if (loot) loot.Initialize(item, qty); // sets sprite/name & canBePickedUp=false
    }
}

// ----- File: INV_Slots.cs -----
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;

public class INV_Slots : MonoBehaviour, IPointerClickHandler
{
    [Header("Data")]
    public INV_ItemSO item;
    public int quantity;

    [Header("UI")]
    public Image icon;
    public TMP_Text qtyText;

    INV_Manager inv;

    void Awake()
    {
        icon    ??= transform.Find("Icon")?.GetComponent<Image>();
        qtyText ??= transform.Find("QuantityText")?.GetComponent<TMP_Text>();
        inv     ??= GetComponentInParent<INV_Manager>();

        if (!icon) Debug.LogError($"{name}: Icon missing.", this);
        if (!qtyText) Debug.LogError($"{name}: QuantityText missing.", this);
        if (!inv) Debug.LogError($"{name}: InventoryManager missing in parent.", this);
    }

    public void UpdateUI()
    {
        if (item != null)
        {
            if (icon)
            {
                icon.enabled = true;
                icon.sprite = item.icon;
            }
            if (qtyText) qtyText.text = quantity.ToString();
        }
        else
        {
            if (icon) icon.enabled = false;
            if (qtyText) qtyText.text = "";
        }
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (item == null || quantity <= 0) return;
            inv.UseItem(this);
        }
        else if (eventData.button == PointerEventData.InputButton.Right)
        {
            if (item == null || quantity <= 0) return;
            inv.DropItemFromSlot(this); // NEW
        }
    }
}

// ----- File: INV_UseItem.cs -----
using System.Collections;
using UnityEngine;

public class INV_UseItem : MonoBehaviour
{
    [Header("Targets")]
    public C_Health       playerHealth;   // drag Player’s C_Health
    public P_StatsChanged playerStats;    // drag Player’s P_StatsChanged

    void Awake()
    {
        playerHealth ??= FindFirstObjectByType<C_Health>();
        playerStats  ??= FindFirstObjectByType<P_StatsChanged>();

        if (!playerHealth) Debug.LogError($"{name}: playerHealth missing.", this);
        if (!playerStats)  Debug.LogError($"{name}: playerStats missing.", this);
    }

    // Returns true if an effect actually applied (so the item should be consumed)
    public bool ApplyItemEffects(INV_ItemSO item)
    {
        if (!item || !playerStats) return false;
        var stats = playerStats.c_Stats; // HP lives here
        bool applied = false;

        // 1) Heal (skip consumption if already full)
        if (item.currentHealth > 0 && playerHealth && stats != null)
        {
            if (stats.currentHP < stats.maxHP) // avoid overheal consumption
            {
                int before = stats.currentHP;
                playerHealth.ChangeHealth(item.currentHealth); // heals since positive
                int after  = stats.currentHP;
                applied |= (after > before);
            }
        }

        // 2) Max HP (perm or temp)
        if (item.maxHealth != 0)
        {
            if (item.durationSec > 0f)
                StartCoroutine(TempStat(ST_SkillSO.Stat.MaxHP, item.maxHealth, item.durationSec, clampHPOnExpire: true));
            else
                playerStats.ApplyStat(ST_SkillSO.Stat.MaxHP, item.maxHealth);
            applied = true;
        }

        // 3) Move Speed (perm or temp)
        if (item.speed != 0)
        {
            if (item.durationSec > 0f)
                StartCoroutine(TempStat(ST_SkillSO.Stat.MS, item.speed, item.durationSec));
            else
                playerStats.ApplyStat(ST_SkillSO.Stat.MS, item.speed);
            applied = true;
        }

        // 4) Damage (map your “damage” to AD here)
        if (item.damage != 0)
        {
            if (item.durationSec > 0f)
                StartCoroutine(TempStat(ST_SkillSO.Stat.AD, item.damage, item.durationSec));
            else
                playerStats.ApplyStat(ST_SkillSO.Stat.AD, item.damage);
            applied = true;
        }

        return applied;
    }

    IEnumerator TempStat(ST_SkillSO.Stat stat, int delta, float duration, bool clampHPOnExpire = false)
    {
        var stats = playerStats.c_Stats;
        playerStats.ApplyStat(stat, delta);
        yield return new WaitForSeconds(duration);
        playerStats.ApplyStat(stat, -delta);

        // If we reduced MaxHP, make sure currentHP isn’t above new cap (don’t fire damage events)
        if (clampHPOnExpire && stats != null && stat == ST_SkillSO.Stat.MaxHP)
            stats.currentHP = Mathf.Min(stats.currentHP, stats.maxHP);
    }
}

