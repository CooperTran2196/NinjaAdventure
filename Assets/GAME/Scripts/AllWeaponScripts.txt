// ----- File: W_Base.cs -----
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(SpriteRenderer))]
[RequireComponent(typeof(BoxCollider2D))]
public abstract class W_Base : MonoBehaviour
{
    [Header("Central API for all weapons")]
    [Header("References")]
    protected SpriteRenderer sprite;
    protected BoxCollider2D hitbox;
    protected Animator ownerAnimator;
    protected C_Stats c_Stats;

    [Header("Weapon Data")]
    public W_SO weaponData;

    [Header("Owner + Targets")]
    public Transform owner;
    public LayerMask targetMask;

    [Header("Auto Sized Hitbox")]
    public bool autoSizeFromSprite = true;

    [Header("Debug")]
    [SerializeField] bool debugDrawHitbox = false;
    [SerializeField] Color debugHitboxColor = new Color(1f, 0.4f, 0.1f, 0.9f); // orange

    void Awake()
    {
        // 1/ Cache weapon components
        sprite ??= GetComponent<SpriteRenderer>();
        hitbox ??= GetComponent<BoxCollider2D>();

        if (!sprite) Debug.LogError($"{name}: SpriteRenderer missing on {gameObject.name}", this);
        if (!hitbox) Debug.LogError($"{name}: BoxCollider2D missing on {gameObject.name}", this);

        // 2/ Collider mode + default visibility
        hitbox.isTrigger = true;     // trigger-based hit detection
        sprite.enabled   = false;      // show only during attack window
        hitbox.enabled   = false;

        // 3/ Owner + deps
        owner = transform.root;
        ownerAnimator ??= owner ? owner.GetComponent<Animator>() : null;
        c_Stats ??= owner ? owner.GetComponent<C_Stats>() : null;
        
        if (!owner)         Debug.LogError($"{name}: Owner (root transform) not found for {gameObject.name}", this);
        if (!ownerAnimator) Debug.LogError($"{name}: Animator missing on owner {owner?.name}", this);
        if (!c_Stats)       Debug.LogError($"{name}: C_Stats missing on owner {owner?.name}", this);
        if (!weaponData)    Debug.LogError($"{name}: W_SO weaponData is not assigned on {gameObject.name}", this);

        // 4/ Visual + hitbox sizing
        if (weaponData && sprite) sprite.sprite = weaponData.sprite;
        if (autoSizeFromSprite && sprite && sprite.sprite)
        {
            hitbox.size = sprite.sprite.bounds.size;
            hitbox.offset = Vector2.zero;
        }
    }

    // Get position around owner at offsetRadius along attackDir
    protected Vector3 GetPolarPosition(Vector2 attackDir) =>
        owner.position + (Vector3)(attackDir * weaponData.offsetRadius);

    // Get angle in degrees from up/down baseline + bias
    protected float GetPolarAngle(Vector2 attackDir)
    {
        // Angle from up/down baseline + bias
        Vector2 baseline = weaponData.pointsUp ? Vector2.up : Vector2.down;
        // Get the signed angle between the baseline and the attack direction
        return Vector2.SignedAngle(baseline, attackDir) + weaponData.angleBiasDeg;
    }

    // Position/rotate + show sprite, optionally enable hitbox
    protected void BeginVisual(Vector3 pos, float angle, bool enableHitbox)
    {
        transform.position = pos;
        transform.rotation = Quaternion.Euler(0, 0, angle);
        sprite.enabled = true;
        hitbox.enabled = enableHitbox;
    }

    // Move forward/back along dir over showTime (no callback)
    protected IEnumerator ThrustOverTime(Vector2 dir, float showTime, float thrustDist)
    {
        float t = 0f;
        Vector3 start = transform.position - (Vector3)(dir * (thrustDist * 0.5f));
        Vector3 end = transform.position + (Vector3)(dir * (thrustDist * 0.5f));

        while (t < showTime)
        {
            t += Time.deltaTime;
            float k = Mathf.Clamp01(t / showTime);
            transform.position = Vector3.Lerp(start, end, k);
            yield return null;
        }
    }
    
    // INSTANCE convenience wrappers for from W_Melee / W_Ranged
    protected (C_Health target, GameObject root) TryGetTarget(Collider2D targetCollider)
        => TryGetTarget(owner, targetMask, targetCollider);

    // STATIC versions for W_Projectile
    public static (C_Health target, GameObject root)
                TryGetTarget(Transform owner, LayerMask targetMask, Collider2D targetCollider)
    {
        // Layer filter
        if ((targetMask.value & (1 << targetCollider.gameObject.layer)) == 0)
            return (null, null);

        // Ignore owner
        if (targetCollider.transform == owner || targetCollider.transform.IsChildOf(owner))
            return (null, null);

        // Ignore weapon–weapon contacts
        if (targetCollider.GetComponentInParent<W_Base>() != null)
            return (null, null);

        // Find target health on targetCollider's root
        var target = targetCollider.GetComponentInParent<C_Health>();
        if (target == null || !target.IsAlive)
            return (null, null);

        // Success -> return C_Health and GameObject
        return (target, target.gameObject);
    }

    // INSTANCE convenience wrappers for from W_Melee / W_Ranged
    protected void ApplyHitEffects(C_Stats attackerStats, W_SO weaponData, C_Health targetHealth, Vector2 dir, Collider2D targetCollider)
                => ApplyHitEffects(attackerStats, weaponData, targetHealth, dir, targetCollider, this);

    // Apply damage + hit effects
    public static void ApplyHitEffects(C_Stats attackerStats, W_SO weaponData, C_Health targetHealth,
                                        Vector2 dir, Collider2D targetCollider, MonoBehaviour weapon)
    {
        int attackerAD = attackerStats.AD, attackerAP = attackerStats.AP;
        int weaponAD = weaponData.AD, weaponAP = weaponData.AP;
        float attackerArmorPen = attackerStats.armorPen;
        float attackerMagicPen = attackerStats.magicPen;

        int dealtDamage = targetHealth.ApplyDamage(attackerAD, attackerAP, weaponAD, weaponAP, attackerArmorPen, attackerMagicPen);

        // LIFESTEAL LOGIC
        // If damage was dealt and the attacker has lifesteal, heal the attacker.
        if (dealtDamage > 0 && attackerStats.lifesteal > 0)
        {
            var attackerHealth = attackerStats.GetComponent<C_Health>();
            if (attackerHealth != null)
            {
                int healAmount = Mathf.RoundToInt(dealtDamage * attackerStats.lifesteal);
                if (healAmount > 0)
                {
                    attackerHealth.ChangeHealth(healAmount);
                }
            }
        }

        // Hit effects
        if (weaponData.knockbackForce > 0f)
            W_Knockback.PushTarget(targetCollider.gameObject, dir, weaponData.knockbackForce);

        if (weaponData.stunTime > 0f)
        {
            var pm = targetCollider.GetComponentInParent<P_Movement>();
            if (pm) { weapon.StartCoroutine(W_Stun.Apply(pm, weaponData.stunTime)); }
            else
            {
                var em = targetCollider.GetComponentInParent<E_Movement>();
                if (em) { weapon.StartCoroutine(W_Stun.Apply(em, weaponData.stunTime)); }
            }
        }
    }

    // Called by owner when attacking
    public abstract void Attack(Vector2 attackDir);

    // Called by owner when equipping
    public virtual void Equip(Transform newOwner)
    {
        owner = newOwner;
        ownerAnimator = owner.GetComponent<Animator>();
        c_Stats = owner.GetComponent<C_Stats>();
    }

    // Change weapon data at runtime
    public void SetData(W_SO weaponData)
    {
        this.weaponData = weaponData;
        sprite.sprite = this.weaponData.sprite;
    }


    // Debug: draw hitbox when active
    void OnDrawGizmos()
    {
        if (!debugDrawHitbox) return;

        // Use cached if available; fall back to GetComponent for edit-time draws
        var sr = sprite ? sprite : GetComponent<SpriteRenderer>();
        var bc = hitbox ? hitbox : GetComponent<BoxCollider2D>();
        if (!bc) return;

        // Only draw while the weapon is live: sprite visible OR collider enabled
        if ((sr && sr.enabled) || bc.enabled)
        {
            var prevMatrix = Gizmos.matrix;
            var prevColor = Gizmos.color;

            Gizmos.matrix = transform.localToWorldMatrix;
            Gizmos.color = debugHitboxColor;

            // Fill (very faint) + outline so it’s easy to see
            var fill = debugHitboxColor; fill.a = 0.12f;
            Gizmos.color = fill; Gizmos.DrawCube(bc.offset, bc.size);
            Gizmos.color = debugHitboxColor; Gizmos.DrawWireCube(bc.offset, bc.size);

            Gizmos.matrix = prevMatrix;
            Gizmos.color = prevColor;
        }
    }
}




// ----- File: W_Knockback.cs -----
using UnityEngine;

public static class W_Knockback
{
    // Push a rigidbody by an impulse along the direction
    public static void Push(Rigidbody2D rb, Vector2 direction, float impulse)
    {
        rb.AddForce(direction * impulse, ForceMode2D.Impulse);
    }

    // Push target
    public static void PushTarget(GameObject target, Vector2 direction, float knockbackForce)
    {
        // Player
        var pm = target.GetComponentInParent<P_Movement>();
        if (pm != null) { pm.ReceiveKnockback(direction * knockbackForce); return; }
        
        // Enemy
        var em = target.GetComponentInParent<E_Movement>();
        if (em != null) { em.ReceiveKnockback(direction * knockbackForce); return; }

        // Others
        var rb = target.GetComponentInParent<Rigidbody2D>();
        if (rb != null) rb.AddForce(direction * knockbackForce, ForceMode2D.Impulse);
    }

    // Radial AoE push (Still incomplete)
    public static int PushRadial(Vector2 center, float radius, float impulse, LayerMask mask)
    {
        int count = 0;
        var hits = Physics2D.OverlapCircleAll(center, radius, mask);
        for (int i = 0; i < hits.Length; i++)
        {
            var rb = hits[i].attachedRigidbody;
            if (rb == null) continue;
            Vector2 dir = (rb.position - center).normalized;
            rb.AddForce(dir * impulse, ForceMode2D.Impulse);
            count++;
        }
        return count;
    }
}

// ----- File: W_Melee.cs -----
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class W_Melee : W_Base
{
    Vector2 attackDir;

    // Track hits to avoid multiple hits on same target during one git
    readonly HashSet<int> alreadyHit = new HashSet<int>();

    // Override attack method
    public override void Attack(Vector2 aimDir)
    {
        attackDir = aimDir.normalized;
        StartCoroutine(Hit());
    }

    // Coroutine for handling the hit process
    IEnumerator Hit()
    {
        // Clear hit tracker after each git
        alreadyHit.Clear();

        // Continuous aim (mouse for Player / player transform for Enemy)
        Vector3 posision = GetPolarPosition(attackDir);
        float angle = GetPolarAngle(attackDir);
        BeginVisual(posision, angle, enableHitbox: true);

        // Thrust
        yield return ThrustOverTime(attackDir, weaponData.showTime, weaponData.thrustDistance);

        // End visuals
        hitbox.enabled = false;
        sprite.enabled = false;
    }

    // Hit detection
    void OnTriggerStay2D(Collider2D targetCollider)
    {
        // Check if the collider is a valid target
        var (targetHealth, root) = TryGetTarget(targetCollider);
        if (targetHealth == null) return;
        if (!alreadyHit.Add(root.GetInstanceID())) return;   // one hit per swing
        ApplyHitEffects(c_Stats, weaponData, targetHealth, attackDir, targetCollider);
    }
}

// ----- File: W_Projectile.cs -----
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(Rigidbody2D))]
public class W_Projectile : MonoBehaviour
{
    // Cache
    SpriteRenderer sprite;
    BoxCollider2D col;
    Rigidbody2D rb;

    // Runtime
    Transform owner;
    C_Stats attackerStats;
    W_SO weaponData;
    LayerMask targetMask;
    Vector2 fireDir;

    int remainingPierces;
    readonly HashSet<int> alreadyHit = new HashSet<int>();

    void Awake()
    {
        sprite ??= GetComponent<SpriteRenderer>();
        col    ??= GetComponent<BoxCollider2D>();
        rb     ??= GetComponent<Rigidbody2D>();

        if (!sprite) Debug.LogError($"{name}: SpriteRenderer missing on {gameObject.name}", this);
        if (!col) Debug.LogError($"{name}: BoxCollider2D missing on {gameObject.name}", this);
        if (!rb) Debug.LogError($"{name}: Rigidbody2D missing on {gameObject.name}", this);

        col.isTrigger = true;
        rb.gravityScale = 0f;
        rb.freezeRotation = true;
    }

    // Called by W_Ranged when spawning
    public void Init(Transform owner, C_Stats attackerStats, W_SO weaponData, Vector2 fireDir, LayerMask targetMask)
    {
        this.owner = owner;
        this.attackerStats = attackerStats;
        this.weaponData = weaponData;
        this.fireDir = fireDir.normalized;
        this.targetMask = targetMask;
        this.remainingPierces = Mathf.Max(0, weaponData.pierceCount);

        // Keep prefab’s arrow sprite (don’t overwrite with weaponData.sprite which is bow art)
        rb.linearVelocity = fireDir * weaponData.projectileSpeed;

        // Auto-destroy after lifetime
        if (weaponData.projectileLifetime > 0f)
            Destroy(gameObject, weaponData.projectileLifetime);
    }

    void OnTriggerEnter2D(Collider2D targetCollider)
    {
        // FILTER via W_Base static
        var (targetHealth, root) = W_Base.TryGetTarget(owner, targetMask, targetCollider);
        if (targetHealth == null) return;

         // Track hits to avoid multiple hits on same target
        if (!alreadyHit.Add(root.GetInstanceID())) return;

        // EFFECTS via W_Base static
        W_Base.ApplyHitEffects(attackerStats, weaponData, targetHealth, fireDir, targetCollider, this);

        // Consume pierce or stop now
        if (remainingPierces > 0)
        {
            remainingPierces--;      // pass through this target
            return;                  // keep flying
        }

        // No more pierce: stick or destroy
        if (weaponData.stickOnHit > 0f)
        {
            StartCoroutine(hit(targetCollider, weaponData.stickOnHit));
        }
        else
        {
            Destroy(gameObject);
        }
    }

    IEnumerator hit(Collider2D targetCollider, float fadeDuration)
    {
        // Compute a precise surface point on the hit collider
        var dist = col.Distance(targetCollider);          // distance info between our collider and hit collider
        Vector2 snap = dist.pointB;               // point on the *hit* collider
        transform.position = snap + (fireDir * 0.02f); // tiny embed so it visually "bites" in

        // Pin it: stop physics & collisions, then parent to the collider
        rb.linearVelocity = Vector2.zero;
        rb.isKinematic = true;
        col.enabled = false;
        transform.SetParent(targetCollider.transform, true);

        // Optional: ensure it renders above the target while stuck
        sprite.sortingOrder += 1;

        // Fade over seconds
        Color c = sprite.color;
        float t = 0f;
        while (t < fadeDuration)
        {
            t += Time.deltaTime;
            float a = 1f - Mathf.Clamp01(t / fadeDuration);
            sprite.color = new Color(c.r, c.g, c.b, a);
            yield return null;
        }

        Destroy(gameObject);
    }
}

// ----- File: W_Ranged.cs -----
using System.Collections;
using UnityEngine;

public class W_Ranged : W_Base
{
    public override void Attack(Vector2 attackDir)
    {
        StartCoroutine(Shoot(attackDir));
    }

    IEnumerator Shoot(Vector2 attackDir)
    {
        // Normalize aim for consistency
        attackDir = attackDir.normalized;

        // Continuous aim (mouse for Player / player transform for Enemy)
        Vector3 posision = GetPolarPosition(attackDir);
        float angle = GetPolarAngle(attackDir);
        BeginVisual(posision, angle, enableHitbox: false);

        // Run the thrust motion in parallel
        StartCoroutine(ThrustOverTime(attackDir, weaponData.showTime, weaponData.thrustDistance));

        // Fire exactly at 50% of the show time
        yield return new WaitForSeconds(weaponData.showTime * 0.5f);
        FireProjectile(attackDir);

        // Finish the remaining half of the show time
        yield return new WaitForSeconds(weaponData.showTime * 0.5f);

        // Hide
        sprite.enabled = false;
    }

    void FireProjectile(Vector2 attackDir)
    {
        // Check prefab
        if (!weaponData.projectilePrefab) return;

        // Spawn from current bow position (mid-thrust)
        Vector3 currentPosition = transform.position;

        // Projectile default art faces RIGHT
        float projAngle = Vector2.SignedAngle(Vector2.right, attackDir);
        
        // Spawn + init
        var go = Instantiate(weaponData.projectilePrefab, currentPosition, Quaternion.Euler(0, 0, projAngle));
        var proj = go.GetComponent<W_Projectile>();
        if (proj != null) proj.Init(owner, c_Stats, weaponData, attackDir, targetMask);
    }
}

// ----- File: W_SO.cs -----
using UnityEngine;

public enum WeaponType { Melee, Ranged, Magic }

[CreateAssetMenu(menuName = "Weapon SO", fileName = "W_SO_NewWeapon")]
public class W_SO : ScriptableObject
{
    [Header("Common")]
    public string id = "weaponId";
    public WeaponType type = WeaponType.Melee;
    public Sprite sprite;
    public bool pointsUp = false; // false = points down
    public float offsetRadius = 0.7f; // polar placement radius
    public float angleBiasDeg = 0f; // optional art twist

    [Header("Damage (set either/both)")]
    public int AD = 1;
    public int AP = 0;

    [Header("Impact")]
    public float knockbackForce = 5f;
    public float stunTime = .5f;

    [Header("Melee timings + Thrust Distance")]
    public float showTime = 0.3f;
    public float thrustDistance = 0.25f;

    [Header("Ranged + Magic")]
    public GameObject projectilePrefab;
    public int manaCost = 0;
    public float projectileSpeed = 0f;
    public float projectileLifetime = 0f;
    public float stickOnHit = 0f;
    public int   pierceCount = 0;
}

// ----- File: W_Stun.cs -----
using System.Collections;
using UnityEngine;

public static class W_Stun
{
    // Stun Player
    public static IEnumerator Apply(P_Movement m, float time)
    {
        m.SetDisabled(true);
        yield return new WaitForSeconds(time);
        m.SetDisabled(false);
    }

    // Stun Enemy
    public static IEnumerator Apply(E_Movement m, float time)
    {
        m.SetDisabled(true);
        yield return new WaitForSeconds(time);
        m.SetDisabled(false);
    }
}

