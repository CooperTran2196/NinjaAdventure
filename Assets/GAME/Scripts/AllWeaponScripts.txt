 
// ----- File: W_ApplyDamage.cs ----- 
using UnityEngine;

public static class W_ApplyDamage
{
    public static void ApplyPhysical(int attackerAD, int weaponBase, C_ChangeHealth target)
    {
        if (target == null || !target.IsAlive) return;
        int requested = attackerAD + weaponBase;
        float reduction = Mathf.Clamp01(target.AR / 100f);
        int reduced = Mathf.RoundToInt(requested * (1f - reduction));
        if (reduced <= 0) return;
        target.ChangeHealth(-reduced);
    }

    public static void ApplyAbility(int attackerAP, int weaponBase, C_ChangeHealth target)
    {
        if (target == null || !target.IsAlive) return;
        int requested = attackerAP + weaponBase;
        float reduction = Mathf.Clamp01(target.MR / 100f);
        int reduced = Mathf.RoundToInt(requested * (1f - reduction));
        if (reduced <= 0) return;
        target.ChangeHealth(-reduced);
    }
}
     
// ----- File: W_Base.cs ----- 
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
[RequireComponent(typeof(BoxCollider2D))]
public abstract class W_Base : MonoBehaviour
{
    [Header("Data")]
    public W_SO data;

    [Header("Owner + Targets")]
    public Transform owner;
    public LayerMask targetMask;

    [Header("Hitbox Auto")]
    public bool autoSizeFromSprite = true;

    [Header("Debug")]
    [SerializeField] bool debugDrawHitbox = false;
    [SerializeField] Color debugHitboxColor = new Color(1f, 0.4f, 0.1f, 0.9f); // orange-red

    const float MIN_DISTANCE = 0.001f;
    // Cached
    protected SpriteRenderer sprite;
    protected BoxCollider2D hitbox;
    protected Animator ownerAnimator;
    protected P_Stats pStats;
    protected E_Stats eStats;

    protected virtual void Awake()
    {
        sprite ??= GetComponent<SpriteRenderer>();
        hitbox ??= GetComponent<BoxCollider2D>();
        hitbox.isTrigger = true;

        // Hide by default and shown only during Attack
        if (sprite) sprite.enabled = false;
        if (hitbox) hitbox.enabled = false;

        owner ??= transform.root;
        ownerAnimator ??= owner ? owner.GetComponent<Animator>() : null;
        pStats ??= owner ? owner.GetComponent<P_Stats>() : null;
        eStats ??= owner ? owner.GetComponent<E_Stats>() : null;

        if (data && sprite) sprite.sprite = data.sprite;
        if (autoSizeFromSprite && sprite && sprite.sprite && hitbox)
        {
            hitbox.size = sprite.sprite.bounds.size;
            hitbox.offset = Vector2.zero;
        }
    
    }

    public virtual void Equip(Transform newOwner)
    {
        owner = newOwner;
        ownerAnimator = owner ? owner.GetComponent<Animator>() : null;
        pStats = owner ? owner.GetComponent<P_Stats>() : null;
        eStats = owner ? owner.GetComponent<E_Stats>() : null;
        if (data && sprite) sprite.sprite = data.sprite;
    }

    public void SetData(W_SO d, bool applySprite = true)
    {
        data = d;
        if (applySprite && data && sprite) sprite.sprite = data.sprite;
    }

    // Read atkX/atkY; normalize if above threshold; else default to down.
    // Always returns a clean 8-way vector from atkX/atkY, or Down if unset
    protected Vector2 GetAimDir()
    {
        if (!ownerAnimator) return Vector2.down;

        float ax = ownerAnimator.GetFloat("atkX");
        float ay = ownerAnimator.GetFloat("atkY");
        Vector2 v = new Vector2(ax, ay);

        if (v.sqrMagnitude <= (MIN_DISTANCE * MIN_DISTANCE)) return Vector2.down;
        return SnapToEightDirections(v);
    }


    // Choose one of the 8 offsets from SO
    protected Vector2 GetSpawnOffset(Vector2 snappedDir)
    {
        if (!data) return Vector2.zero;

        float t = MIN_DISTANCE;
        bool hasX = Mathf.Abs(snappedDir.x) > t;
        bool hasY = Mathf.Abs(snappedDir.y) > t;

        if (hasX && hasY)
        {
            if (snappedDir.x >= 0f && snappedDir.y >= 0f) return data.offsetUpRight;
            if (snappedDir.x < 0f && snappedDir.y >= 0f) return data.offsetUpLeft;
            if (snappedDir.x >= 0f && snappedDir.y < 0f) return data.offsetDownRight;
            return data.offsetDownLeft;
        }
        if (hasX) return (snappedDir.x >= 0f) ? data.offsetRight : data.offsetLeft;
        return (snappedDir.y >= 0f) ? data.offsetUp : data.offsetDown;
    }


    // Shared math utility (same as enemy)
    protected static Vector2 SnapToEightDirections(Vector2 direction)
    {
        if (direction.sqrMagnitude < 1e-9f) return Vector2.down;
        float degrees = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        int octantIndex = Mathf.RoundToInt(degrees / 45f);
        float radians = octantIndex * 45f * Mathf.Deg2Rad;
        return new Vector2(Mathf.Cos(radians), Mathf.Sin(radians)).normalized;
    }


    public abstract void Attack();

    void OnDrawGizmos()
    {
        if (!debugDrawHitbox) return;

        // Use cached if available; fall back to GetComponent for edit-time draws
        var sr = sprite ? sprite : GetComponent<SpriteRenderer>();
        var bc = hitbox ? hitbox : GetComponent<BoxCollider2D>();
        if (!bc) return;

        // Only draw while the weapon is "live": sprite visible OR collider enabled
        if ((sr && sr.enabled) || bc.enabled)
        {
            var prevMatrix = Gizmos.matrix;
            var prevColor = Gizmos.color;

            Gizmos.matrix = transform.localToWorldMatrix;
            Gizmos.color = debugHitboxColor;

            // Fill (very faint) + outline so it’s easy to see
            var fill = debugHitboxColor; fill.a = 0.12f;
            Gizmos.color = fill; Gizmos.DrawCube(bc.offset, bc.size);
            Gizmos.color = debugHitboxColor; Gizmos.DrawWireCube(bc.offset, bc.size);

            Gizmos.matrix = prevMatrix;
            Gizmos.color = prevColor;
        }
    }
}



 
// ----- File: W_Knockback.cs ----- 
using UnityEngine;

public static class W_Knockback
{
    // Push a rigidbody by an impulse along the direction
    public static void Push(Rigidbody2D rb, Vector2 direction, float impulse)
    {
        rb.AddForce(direction * impulse, ForceMode2D.Impulse);
    }

    // Push target
    public static void PushTarget(GameObject target, Vector2 direction, float knockbackForce)
    {
        // Player
        var pm = target.GetComponentInParent<P_Movement>();
        if (pm != null) { pm.ReceiveKnockback(direction * knockbackForce); return; }
        
        // Enemy
        var em = target.GetComponentInParent<E_Movement>();
        if (em != null) { em.ReceiveKnockback(direction * knockbackForce); return; }

        // Others
        var rb = target.GetComponentInParent<Rigidbody2D>();
        if (rb != null) rb.AddForce(direction * knockbackForce, ForceMode2D.Impulse);
    }

    // Radial AoE push
    public static int PushRadial(Vector2 center, float radius, float impulse, LayerMask mask)
    {
        int count = 0;
        var hits = Physics2D.OverlapCircleAll(center, radius, mask);
        for (int i = 0; i < hits.Length; i++)
        {
            var rb = hits[i].attachedRigidbody;
            if (rb == null) continue;
            Vector2 dir = (rb.position - center).normalized;
            rb.AddForce(dir * impulse, ForceMode2D.Impulse);
            count++;
        }
        return count;
    }
}
 
// ----- File: W_Melee.cs ----- 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class W_Melee : W_Base
{   
    readonly HashSet<int> hitThisSwing = new HashSet<int>();

    public override void Attack()
    {
        StartCoroutine(Swing());
    }

    IEnumerator Swing()
    {
        Vector2 dir = GetAimDir();                      // snapped to 8-way
        Vector3 spawn = owner.position + (Vector3)GetSpawnOffset(dir);

        // rotate from baseline depending on art (up vs down)
        Vector2 baseline = (data != null && data.pointsUp) ? Vector2.up : Vector2.down;
        float angle = Vector2.SignedAngle(baseline, dir);

        transform.position = spawn;
        transform.rotation = Quaternion.Euler(0, 0, angle);
        hitThisSwing.Clear();
        
        // Show + enable hitbox
        sprite.enabled = true;
        hitbox.enabled = true;

        // Thrust over showTime
        float t = 0f;
        Vector3 start = transform.position - (Vector3)(dir * (data.thrustDistance * 0.5f));
        Vector3 end   = transform.position + (Vector3)(dir * (data.thrustDistance * 0.5f));
        while (t < data.showTime)
        {
            t += Time.deltaTime;
            float k = Mathf.Clamp01(t / data.showTime);
            transform.position = Vector3.Lerp(start, end, k);
            yield return null;
        }

        // Hide
        hitbox.enabled = false;
        sprite.enabled = false;
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        // Layer filter -> only react to colliders on targetMask
        if ((targetMask.value & (1 << other.gameObject.layer)) == 0) return;

        // Ignore owner
        if (other.transform == owner || other.transform.IsChildOf(owner)) return;

        // Ignore weapon–weapon contacts
        if (other.GetComponentInParent<W_Base>() != null) return;

        // Damage = (attacker AD) + (weapon baseDamage)
        int attackerAD = (pStats != null) ? pStats.AD : (eStats != null ? eStats.AD : 0);
        int weaponBase = (data ? data.baseDamage : 0);

        // Apply damage
        bool hit = false;
        var targetHealth = other.GetComponentInParent<C_ChangeHealth>();
        if (targetHealth != null)
        {
            W_ApplyDamage.ApplyPhysical(attackerAD, weaponBase, targetHealth);
            hit = true;
        }


        var ec = other.GetComponentInParent<E_Combat>();
        if (ec != null) { ec.ChangeHealth(-final); hit = true; }

        // Per-swing de-dup
        GameObject root = targetHealth ? targetHealth.gameObject : null;
        if (root == null) return;
        if (!hitThisSwing.Add(root.GetInstanceID())) return;


        // Knockback
        if (hit && data != null && data.knockbackForce > 0f)
        {
             // 8-way snapped aim direction
            Vector2 dir = GetAimDir(); // snapped 8-way from W_Base
            W_Knockback.PushTarget(other.gameObject, dir, data.knockbackForce);
        }

        // Stun time
        if (data != null && data.stunTime > 0f)
        {
            var pm = other.GetComponentInParent<P_Movement>();
            if (pm != null) { StartCoroutine(W_Stun.Apply(pm, data.stunTime)); }
            else
            {
                var em = other.GetComponentInParent<E_Movement>();
                if (em != null) { StartCoroutine(W_Stun.Apply(em, data.stunTime)); }
            }
        }


    }
}
 
// ----- File: W_SO.cs ----- 
using UnityEngine;

public enum WeaponType { Melee, Ranged, Magic }

[CreateAssetMenu(menuName = "GAME/Weapon SO", fileName = "W_SO_NewWeapon")]
public class W_SO : ScriptableObject
{
    [Header("Common")]
    public string id = "weapon_id";
    public WeaponType type = WeaponType.Melee;
    public Sprite sprite;
    public bool pointsUp = false; // false = points down
    public int baseDamage = 1;
    public float knockbackForce = 5f;
    public float stunTime = .5f;

    [Header("Melee timings & radial offset")]
    public float showTime = 0.3f;
    public float thrustDistance = 0.25f;

    [Header("Optional directional offsets")]
    [Header("Cardinals")]
    public Vector2 offsetDown = new Vector2(-0.2f, -0.75f);
    public Vector2 offsetUp = new Vector2(-0.2f, 0.75f);
    public Vector2 offsetLeft = new Vector2(-0.7f, -0.25f);
    public Vector2 offsetRight = new Vector2(0.7f, -0.25f);
    [Header("Diagonals")]
    public Vector2 offsetUpRight    = new Vector2(0.5f, 0.5f);
    public Vector2 offsetUpLeft     = new Vector2(-0.5f, 0.5f);
    public Vector2 offsetDownRight  = new Vector2(0.5f, -0.75f);
    public Vector2 offsetDownLeft   = new Vector2(-0.5f, 0.75f);

    [Header("Ranged (placeholders)")]
    public GameObject projectilePrefab;
    public float projectileSpeed = 8f;

    [Header("Magic (placeholders)")]
    public int manaCost = 0;
}
 
// ----- File: W_Stun.cs ----- 
using System.Collections;
using UnityEngine;

public static class W_Stun
{
    // Stun Player
    public static IEnumerator Apply(P_Movement m, float time)
    {
        m.SetDisabled(true);
        yield return new WaitForSeconds(time);
        m.SetDisabled(false);
    }

    // Stun Enemy
    public static IEnumerator Apply(E_Movement m, float time)
    {
        m.SetDisabled(true);
        yield return new WaitForSeconds(time);
        m.SetDisabled(false);
    }
}
 
