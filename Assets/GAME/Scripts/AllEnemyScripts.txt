// ----- File: B_Controller.cs -----
using UnityEngine;

[DisallowMultipleComponent]
[RequireComponent(typeof(Rigidbody2D))]
public class B_Controller : MonoBehaviour, I_Controller
{
    public enum BState { Idle, Wander, Chase, Attack }

    [Header("States")]
    public BState defaultState = BState.Idle;
    public State_Idle        idle;
    public State_Wander      wander;
    public State_Chase_Boss  chase;
    public State_Attack_Boss attack;

    [Header("Detection")]
    [Min(0.1f)] public float detectionRange = 5f;
    [Min(0.1f)] public float attackRange    = 1.6f;
    public LayerMask playerLayer;
    public float attackStartBuffer = 0.20f;

    Rigidbody2D rb;
    Vector2 desiredVelocity;

    Transform target;
    float inRangeTimer;
    BState current;

    void Awake()
    {
        idle   ??= GetComponent<State_Idle>();
        wander ??= GetComponent<State_Wander>();
        chase  ??= GetComponent<State_Chase_Boss>();
        attack ??= GetComponent<State_Attack_Boss>();
        rb     ??= GetComponent<Rigidbody2D>();
    }

    void OnEnable()
    {
        desiredVelocity = Vector2.zero;
        if (rb) rb.linearVelocity = Vector2.zero;

        chase?.SetRanges(attackRange);
        attack?.SetRanges(attackRange);
        SwitchState(defaultState);
    }

    void OnDisable()
    {
        if (idle)   idle.enabled   = false;
        if (wander) wander.enabled = false;
        if (chase)  chase.enabled  = false;
        if (attack) attack.enabled = false;

        desiredVelocity = Vector2.zero;
        if (rb) rb.linearVelocity = Vector2.zero;
    }

    // -------- I_Controller --------
    public void SetDesiredVelocity(Vector2 v) => desiredVelocity = v;

    void FixedUpdate()
    {
        if (!rb) return;
        rb.linearVelocity = desiredVelocity;
    }

    void Update()
    {
        Vector2 pos = transform.position;

        var cAtk = Physics2D.OverlapCircle(pos, attackRange,    playerLayer);
        var cDet = cAtk ?? Physics2D.OverlapCircle(pos, detectionRange, playerLayer);

        bool inAttack = cAtk;
        bool inDetect = cDet;

        if (inDetect) target = cDet.transform;

        inRangeTimer = inAttack ? inRangeTimer + Time.deltaTime : 0f;
        bool readyMelee = inAttack && inRangeTimer >= attackStartBuffer;

        // ask the boss state if special is available now (uses timing reach, stop-short, y gate)
        bool readySpecial = false;
        if (attack && target)
            readySpecial = attack.CanSpecialNow(transform.position, target.position);

        bool attackingNow = attack && attack.IsAttacking;

        var desired =
            attackingNow   ? BState.Attack :
            readySpecial   ? BState.Attack :
            readyMelee     ? BState.Attack :
            inDetect       ? BState.Chase  :
                             defaultState;

        if (desired != current) SwitchState(desired);
    }

    public void SwitchState(BState s)
    {
        current = s;

        if (idle)   idle.enabled   = (s == BState.Idle);
        if (wander) wander.enabled = (s == BState.Wander);
        if (chase)  chase.enabled  = (s == BState.Chase);
        if (attack) attack.enabled = (s == BState.Attack);

        if (s == BState.Chase)
        {
            chase?.SetTarget(target);
            chase?.SetRanges(attackRange);
            desiredVelocity = Vector2.zero;
        }
        else if (s == BState.Attack)
        {
            attack?.SetTarget(target);
            attack?.SetRanges(attackRange);
            desiredVelocity = Vector2.zero;
        }
        else desiredVelocity = Vector2.zero;
    }

    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0.65f, 0f);
        Gizmos.DrawWireSphere(transform.position, detectionRange);

        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}

// ----- File: E_Controller.cs -----
using System.Collections;
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(Animator))]
[RequireComponent(typeof(State_Idle))]
[RequireComponent(typeof(State_Wander))]
[RequireComponent(typeof(State_Chase))]
[RequireComponent(typeof(State_Attack))]
[RequireComponent(typeof(C_Stats))]
[RequireComponent(typeof(C_Health))]
[DisallowMultipleComponent]

public class E_Controller : MonoBehaviour, I_Controller
{
    public enum EState { Idle, Wander, Chase, Attack, Dead }

    [Header("Main controller for enemy AI states")]
    [Header("References")]
    [Min(3f)]   public float detectionRange = 3f;
    [Min(1.2f)] public float attackRange = 1.2f;
                public LayerMask playerLayer;
                public EState defaultState = EState.Idle;
                public EState currentState;
                
    [Header("Weapons")]
    // public W_Base activeWeapon; // No longer needed, State_Attack will handle it

    [Header("Attack Delay Buffer (For Easy/Hard Mode)")]
    public float attackStartBuffer = 0.2f;  

    Rigidbody2D     rb;
    Animator        anim;

    State_Idle      idle;
    State_Wander    wander;
    State_Chase     chase;
    State_Attack    attack;
    C_Stats         c_Stats;
    C_Health        c_Health;

    // Runtime vars
    Transform       currentTarget;
    Vector2         knockback, desiredVelocity; //, attackDir, lastAimDir;
    bool            isStunned, isDead, isAttacking;    
    float           stunUntil, attackCooldown, attackInRangeTimer, contactTimer;

    void Awake()
    {
        rb           = GetComponent<Rigidbody2D>();
        anim         = GetComponentInChildren<Animator>();

        idle         = GetComponent<State_Idle>();
        wander       = GetComponent<State_Wander>();
        chase        = GetComponent<State_Chase>();
        attack       = GetComponent<State_Attack>();
        c_Stats      = GetComponent<C_Stats>();
        c_Health     = GetComponent<C_Health>();

        anim.SetFloat("moveX", 0f);
        anim.SetFloat("moveY", -1f);
        anim.SetFloat("idleX", 0f);
        anim.SetFloat("idleY", -1f);
    }

    void OnEnable()
    {
        c_Health.OnDied += OnDiedHandler;
        SwitchState(defaultState);
    }

    void OnDisable()
    {
        c_Health.OnDied -= OnDiedHandler;
        idle.enabled = wander.enabled = chase.enabled = attack.enabled = false;
    }

    void OnDiedHandler() => SwitchState(EState.Dead);

    void Update()
    {
        // Death override
        if (isDead) return;
        if (attackCooldown > 0f) attackCooldown -= Time.deltaTime;

        ProcessAI();
    }

    void FixedUpdate()
    {
        // Apply this frame: block state intent when stunned/dead, but still allow knockback
        Vector2 baseVel = (isDead || isStunned) ? Vector2.zero : desiredVelocity;
        rb.linearVelocity = baseVel + knockback;

        // Decay knockback for the NEXT frame
        if (!isDead)
        {
            knockback = Vector2.MoveTowards(knockback, Vector2.zero, c_Stats.KR * Time.fixedDeltaTime);
        }
    }

    void ProcessAI()
    {
        // 1/ Early exit conditions
        if (c_Stats.currentHP <= 0)
        {
            SwitchState(EState.Dead);
            return;
        }

        // Never interrupt an active attack animation
        if (isAttacking) return;

        // 2/ Sense for the player and update target
        Collider2D targetInAttackRange = Physics2D.OverlapCircle(transform.position, attackRange, playerLayer);
        Collider2D targetInDetectRange = targetInAttackRange ?? Physics2D.OverlapCircle(transform.position, detectionRange, playerLayer);

        currentTarget = targetInDetectRange ? targetInDetectRange.transform : null;

        // 3/ Decide on the next state based on target's position
        if (currentTarget == null)
        {
            SwitchState(defaultState);
            attackInRangeTimer = 0f; // Reset timer when no target
            return;
        }

        // Update timer only when a target is in attack range
        if (targetInAttackRange)
            attackInRangeTimer += Time.deltaTime;

        else // Reset if target steps out of range
            attackInRangeTimer = 0f;

        // Check if conditions are met to perform an attack
        bool canAttack = targetInAttackRange 
                      && attackInRangeTimer >= attackStartBuffer 
                      && attackCooldown <= 0f;

        if (canAttack)
            SwitchState(EState.Attack);
        else // If not attacking, but target is detected, chase it
            SwitchState(EState.Chase);
    }

    // Switch states, enabling the chosen one and disabling others
    public void SwitchState(EState state)
    {
        if (currentState == state) return;
        currentState = state;

        // disable all states first
        idle.enabled = wander.enabled = chase.enabled = attack.enabled = false;

        switch (state)
        {
            case EState.Dead: // Highest priority
                desiredVelocity     = Vector2.zero;
                knockback           = Vector2.zero;
                rb.linearVelocity   = Vector2.zero;
                isDead              = true;
                isAttacking         = false;
                isStunned           = false;

                anim.SetTrigger("Die");
                break;

            case EState.Attack:
                desiredVelocity     = Vector2.zero;
                attack.enabled      = true;
                isAttacking         = true;
                attackCooldown      = c_Stats.attackCooldown;
                break;

            case EState.Chase:
                chase.enabled       = true;
                break;

            case EState.Wander:
                wander.enabled      = true;
                break;

            case EState.Idle: // Lowest priority
                desiredVelocity     = Vector2.zero;
                idle.enabled        = true;
                break;
        }
    }

    // Stun coroutine called by W_Base when applying stun effect
    public IEnumerator StunFor(float duration)
    {
        if (duration <= 0f) yield break;

        // Extend the stun end if a longer one arrives
        float newEnd = Time.time + duration;
        if (newEnd > stunUntil) stunUntil = newEnd;

        isStunned = true;
        while (Time.time < stunUntil) yield return null;

        isStunned = false;
    }

    // Collision damage while touching player
    void OnCollisionStay2D(Collision2D collision)
    {
        if (isDead) return;

        // Only interact with the player layer (you already have playerLayer on the controller)
        if ((playerLayer.value & (1 << collision.collider.gameObject.layer)) == 0) return;

        // Throttle ticks using physics timestep
        if (contactTimer > 0f) { contactTimer -= Time.fixedDeltaTime; return; }

        // Apply damage if player has C_Health
        var playerHealth = collision.collider.GetComponent<C_Health>();
        if (!playerHealth.IsAlive) return;

        playerHealth.ChangeHealth(-c_Stats.collisionDamage);   // apply tick damage
        contactTimer = c_Stats.collisionTick;                  // reset tick window
    }

    // Get/Set methods
    public void SetDesiredVelocity(Vector2 desiredVelocity) => this.desiredVelocity = desiredVelocity;
    public void SetAttacking(bool value) => isAttacking = value;
    public void ReceiveKnockback(Vector2 impulse) => knockback += impulse;
    public Transform GetTarget() => currentTarget;
    public float GetAttackRange() => attackRange;
    
    // DEBUG: visualize detection/attack ranges
    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0.65f, 0f);
        Gizmos.DrawWireSphere(transform.position, detectionRange);

        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}

// ----- File: E_HealthBarSlider.cs -----
// File: E_HealthBarSlider.cs  (enemy-only, green-only)
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(CanvasGroup))]
[DisallowMultipleComponent]

public class E_HealthBarSlider : MonoBehaviour
{
    [Header("References")]
    CanvasGroup cg;

    public C_Health e_Health; // Health in parent
    public Slider   slider;   // slider in child

    [Header("World Positioning")]
    public Vector3 worldOffset = new Vector3(0f, 1.5f, 0f);

    [Header("Visibility")]
    public float visibleTime = 2f;   // auto-hide delay
    public bool  startHidden = true; // start invisible until first event

    float hideTimer;

    void Awake()
    {
        cg       ??= GetComponent<CanvasGroup>();
        e_Health ??= GetComponentInParent<C_Health>();

        if (!e_Health) Debug.LogError($"{name}: C_Health is missing in E_HealthBarSlider");
        if (!slider)   Debug.LogError($"{name}: Slider is missing in E_HealthBarSlider");
    }

    void OnEnable()
    {
        var s           = e_Health.c_Stats;      // current/max HP live here
        slider.maxValue = s.maxHP;     // make slider track the true max
        slider.value    = s.currentHP; // initialize to current

        if (startHidden) cg.alpha = 0f;

        e_Health.OnDamaged += OnDamaged;
        e_Health.OnHealed  += OnHealed;
        e_Health.OnDied    += OnDied;
    }

    void OnDisable()
    {
        e_Health.OnDamaged -= OnDamaged;
        e_Health.OnHealed  -= OnHealed;
        e_Health.OnDied    -= OnDied;
    }

    // LateUpdate to ensure it runs after all movement
    void LateUpdate()
    {
        // follow owner
        transform.position = e_Health.transform.position + worldOffset;

        // handle fade-out timer
        if (hideTimer > 0f)
        {
            hideTimer -= Time.deltaTime;
            if (hideTimer <= 0f) cg.alpha = 0f;
        }
    }

    // Event handlers
    void OnDamaged(int amount)
    {
        slider.value = e_Health.c_Stats.currentHP;
        Show();
    }

    void OnHealed(int amount)
    {
        slider.value = e_Health.c_Stats.currentHP;
        Show();
    }

    void OnDied()
    {
        cg.alpha = 0f; // death visuals handled elsewhere
    }

    void Show()
    {
        cg.alpha = 1f;
        hideTimer = visibleTime;
    }
}

// ----- File: E_Reward.cs -----
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[System.Serializable]
public class LootDrop
{
    public INV_ItemSO item;
    [Header("How many of this item to drop.")]
    public int quantity = 1;
}

public class E_Reward : MonoBehaviour
{
    [Header("Rewards")]
    public int expReward = 10; // tweak per enemy prefab

    [Header("Loot")]
    [Tooltip("The prefab with INV_Loot script to spawn when dropping items.")]
    public GameObject lootPrefab;
    [Tooltip("The horizontal distance items can spread out when dropped.")]
    public float dropSpread = 0.75f;
    [Tooltip("Chance (0-100%) to drop any items at all.")]
    [Range(0, 100)] public float dropChance = 50f;
    [Tooltip("How many different items to drop from the loot table.")]
    public int numberOfDrops = 1;
    [Tooltip("A list of all possible items this enemy can drop.")]
    public List<LootDrop> lootTable;

    C_Health c_Health;
    static P_Exp p_Exp;

    void Awake()
    {
        c_Health ??= GetComponentInParent<C_Health>();
        if (!p_Exp) p_Exp = FindFirstObjectByType<P_Exp>();

        if (!c_Health) Debug.LogError($"{name}: C_Health is missing in E_Reward");
        if (!p_Exp) Debug.LogError($"{name}: P_Exp is missing in E_Reward");
    }

    void OnEnable()
    {
        c_Health.OnDied += HandleDied;
    }

    void OnDisable()
    {
        c_Health.OnDied -= HandleDied;
    }

    void HandleDied()
    {
        // Grant EXP and Kill
        if (p_Exp != null)
        {
            p_Exp.AddXP(expReward);
            p_Exp.AddKill();
        }

        // --- Handle Loot Drops ---
        if (lootPrefab == null || lootTable.Count == 0) return;

        // 1. Check if we should drop anything based on drop chance
        if (Random.Range(0f, 100f) > dropChance) return;

        // 2. Determine which items to drop
        List<LootDrop> itemsToDrop = new List<LootDrop>();
        if (numberOfDrops >= lootTable.Count)
        {
            // Drop all items if requested number is greater or equal
            itemsToDrop.AddRange(lootTable);
        }
        else
        {
            // Select a random subset of unique items to drop
            itemsToDrop = lootTable.OrderBy(x => Random.value).Take(numberOfDrops).ToList();
        }

        // 3. Spawn the loot items
        foreach (var lootDrop in itemsToDrop)
        {
            SpawnLoot(lootDrop);
        }
    }

    void SpawnLoot(LootDrop lootDrop)
    {
        if (lootDrop == null || lootDrop.item == null || lootDrop.quantity <= 0) return;

        // Calculate a random spawn position with a horizontal offset
        float randomX = Random.Range(-dropSpread, dropSpread);
        Vector2 spawnPos = new Vector2(transform.position.x + randomX, transform.position.y);

        // Instantiate the loot prefab at the calculated position
        GameObject lootGO = Instantiate(lootPrefab, spawnPos, Quaternion.identity);
        
        // Initialize the loot item
        INV_Loot loot = lootGO.GetComponent<INV_Loot>();
        if (loot != null)
        {
            // Initialize will now handle the animation trigger and pickup delay
            loot.Initialize(lootDrop.item, lootDrop.quantity);
        }
    }
}

// ----- File: State_Attack_Boss.cs -----
using System.Collections;
using UnityEngine;

public class State_Attack_Boss : MonoBehaviour
{
    [Header("Target Layer")]
    public LayerMask playerLayer;

    [Header("Normal Attack")]
    public float attackCooldown = 1.10f;
    float attackDuration = 0.45f;
    float hitDelay = 0.25f;

    [Header("Special (single clip flow)")]
    public float specialCooldown   = 8.0f;
    public float specialClipLength = 1.50f;
    public float specialHitDelay   = 0.50f;   // charge ends → start dash
    public float hitTime           = 1.05f;   // first contact; follow-up auto

    [Header("Auto Move Window")]
    [Tooltip("Dash ends slightly before the hit for fairness.")]
    public float preHitStopBias = 0.02f;      // 10–30 ms typical

    [Header("Dash")]
    public float dashSpeed       = 9.0f;
    public float stopShortOffset = 0.96f;     // distance kept in front of the player (along X) at the end

    [Header("Alignment Gate")]
    public float yHardCap = 0.55f;            // must be within this to attack

    [Header("Weapon")]
    public W_Base activeWeapon;               // W_Melee, no sprite

    // Animator params
    const string kIsAttacking     = "isAttacking";
    const string kIsSpecialAttack = "isSpecialAttack";

    // Cache
    Rigidbody2D rb;
    Animator anim;
    I_Controller controller;
    SpriteRenderer sr;
    C_AfterimageSpawner afterimage;

    // Runtime
    Transform target;
    Vector2 lastFace = Vector2.right;
    float attackRange = 1.6f;

    // Local cooldowns
    float nextAttackReadyAt;
    float nextSpecialReadyAt;

    // Status
    public bool IsAttacking { get; private set; }
    bool isDashing;

    // follow-up gap for the continuous second swing
    const float kFollowupGap = 0.14f;

    // ---- Computed move window (time & reach) ----
    float ComputedMoveWindow
    {
        get
        {
            float w = hitTime - specialHitDelay - preHitStopBias;
            return (w > 0f) ? w : 0f;
        }
    }
    float TimeReach => dashSpeed * ComputedMoveWindow;

    void Awake()
    {
        rb         ??= GetComponent<Rigidbody2D>();
        anim       ??= GetComponentInChildren<Animator>();
        controller ??= GetComponent<I_Controller>();
        activeWeapon ??= GetComponentInChildren<W_Base>();
        sr         ??= GetComponentInChildren<SpriteRenderer>();
        afterimage ??= sr ? sr.GetComponent<C_AfterimageSpawner>() : null;
    }

    void OnDisable()
    {
        IsAttacking = false;
        isDashing   = false;
        controller?.SetDesiredVelocity(Vector2.zero);
        if (rb) rb.linearVelocity = Vector2.zero;
        anim.SetBool(kIsAttacking, false);
        anim.SetBool(kIsSpecialAttack, false);
    }

    void Update()
    {
        if (!isDashing) controller?.SetDesiredVelocity(Vector2.zero);
        if (!target) return;

        Vector2 to = (Vector2)target.position - (Vector2)transform.position;
        float dx = to.x, dy = to.y;
        float d  = to.magnitude;

        Vector2 dir = d > 0.0001f ? to.normalized : lastFace;
        UpdateIdleFacing(IsAttacking ? lastFace : dir);

        // gates
        bool inInner       = Physics2D.OverlapCircle((Vector2)transform.position, attackRange, playerLayer);
        bool specialReady  = Time.time >= nextSpecialReadyAt;
        // new outer uses timing reach (no magenta cap)
        float inner = attackRange * 1.2f;
        float outer = attackRange + TimeReach;
        bool inSpecialDist = Mathf.Abs(dx) >= inner && Mathf.Abs(dx) <= outer;
        bool alignedY      = Mathf.Abs(dy) <= yHardCap;
        bool canAttackNow  = Time.time >= nextAttackReadyAt;

        if (!IsAttacking && canAttackNow)
        {
            if (specialReady && alignedY && inSpecialDist)
            {
                StartCoroutine(SpecialRoutine(dir));
                return;
            }
            if (alignedY && inInner)
            {
                StartCoroutine(NormalRoutine(dir));
                return;
            }
        }
    }

    // -------- controller hooks ----------
    public void SetTarget(Transform t) => target = t;
    public void SetRanges(float attackRange) => this.attackRange = attackRange;

    // Let B_Controller ask if special is valid right now (uses timing reach + Y gate)
    public bool CanSpecialNow(Vector2 bossPos, Vector2 playerPos)
    {
        if (Time.time < nextSpecialReadyAt || Time.time < nextAttackReadyAt) return false;
        float dx = Mathf.Abs(playerPos.x - bossPos.x);
        float dy = Mathf.Abs(playerPos.y - bossPos.y);
        float inner = attackRange * 1.2f;
        float outer = attackRange + TimeReach;
        return dy <= yHardCap && dx >= inner && dx <= outer;
    }

    // -------- normal attack ----------
    IEnumerator NormalRoutine(Vector2 dirAtStart)
    {
        IsAttacking = true;
        anim.SetBool(kIsSpecialAttack, false);
        anim.SetBool(kIsAttacking, true);

        if (dirAtStart.sqrMagnitude > 0f) lastFace = dirAtStart.normalized;
        anim.SetFloat("atkX", lastFace.x);
        anim.SetFloat("atkY", lastFace.y);
        UpdateIdleFacing(lastFace);

        yield return new WaitForSeconds(hitDelay);

        activeWeapon?.Attack(lastFace);

        yield return new WaitForSeconds(Mathf.Max(0f, attackDuration - hitDelay));

        nextAttackReadyAt = Time.time + attackCooldown;
        IsAttacking = false;
        anim.SetBool(kIsAttacking, false);
    }

    // -------- special (one clip; timers only) ----------
    IEnumerator SpecialRoutine(Vector2 dirAtStart)
    {
        IsAttacking = true;
        anim.SetBool(kIsAttacking, false);
        anim.SetBool(kIsSpecialAttack, true);

        if (dirAtStart.sqrMagnitude > 0f) lastFace = dirAtStart.normalized;
        anim.SetFloat("atkX", lastFace.x);
        anim.SetFloat("atkY", lastFace.y);
        UpdateIdleFacing(lastFace);

        float t = 0f;
        float endMoveTime = specialHitDelay + ComputedMoveWindow;

        // A) Charge
        while (t < specialHitDelay) { t += Time.deltaTime; yield return null; }

        // B) Gap-close along vector to the "face spot"
        BeginDash(); // sets velocity and kicks afterimage
        while (t < endMoveTime)
        {
            t += Time.deltaTime;
            if (ReachedDashDest()) break;
            yield return null;
        }
        StopDash();

        // C) Hit + quick follow-up
        while (t < hitTime) { t += Time.deltaTime; yield return null; }
        activeWeapon?.Attack(lastFace);

        float t2 = 0f;
        while (t2 < kFollowupGap) { t2 += Time.deltaTime; yield return null; }
        activeWeapon?.Attack(lastFace);

        // D) Finish clip
        while (t < specialClipLength) { t += Time.deltaTime; yield return null; }

        nextAttackReadyAt  = Time.time + attackCooldown;   // reuse normal pacing after special
        nextSpecialReadyAt = Time.time + specialCooldown;

        IsAttacking = false;
        anim.SetBool(kIsSpecialAttack, false);
    }

    // -------- dash helpers ----------
    Vector2 dashDest;
    Vector2 dashDir;

    void BeginDash()
    {
        // “Face spot”: X is right in front of player (stop-short), Y is exactly player’s Y.
        Vector2 start = transform.position;
        Vector2 p     = target ? (Vector2)target.position : start;

        int sign = (p.x - start.x) >= 0f ? +1 : -1;
        Vector2 faceSpot = new Vector2(p.x - sign * stopShortOffset, p.y);

        Vector2 toFace   = faceSpot - start;
        float distToFace = toFace.magnitude;

        float travel = Mathf.Min(distToFace, TimeReach); // no magenta cap
        dashDir = (toFace.sqrMagnitude > 0f) ? (toFace / distToFace) : new Vector2(sign, 0f);
        dashDest = start + dashDir * travel;

        // velocity & afterimage
        controller?.SetDesiredVelocity(dashDir * dashSpeed);
        isDashing = true;

        if (afterimage && sr)
            afterimage.StartBurst(ComputedMoveWindow, sr.sprite, sr.flipX, sr.flipY);
    }

    void StopDash()
    {
        isDashing = false;
        controller?.SetDesiredVelocity(Vector2.zero);
        if (rb) rb.linearVelocity = Vector2.zero;
    }

    bool ReachedDashDest()
    {
        Vector2 pos = transform.position;
        // stop when we pass the destination along the dash direction
        Vector2 toDest = dashDest - pos;
        return Vector2.Dot(toDest, dashDir) <= 0f || (toDest.sqrMagnitude <= 0.0004f);
    }

    // -------- anim lattice ----------
    void UpdateIdleFacing(Vector2 faceDir)
    {
        anim.SetFloat("moveX", 0f);
        anim.SetFloat("moveY", 0f);
        Vector2 f = faceDir.sqrMagnitude > 0f ? faceDir.normalized : lastFace;
        anim.SetFloat("idleX", f.x);
        anim.SetFloat("idleY", f.y);
    }

    // -------- gizmos ----------
    void OnDrawGizmosSelected()
    {
        Vector3 p = transform.position;

        // Y hard cap band (cyan)
        Gizmos.color = Color.cyan;
        float band = yHardCap;
        float width = (attackRange + TimeReach + 0.5f) * 2f;
        Vector3 L  = p + Vector3.left  * width * 0.5f;
        Vector3 R  = p + Vector3.right * width * 0.5f;
        Gizmos.DrawLine(L + Vector3.up * band,   R + Vector3.up * band);
        Gizmos.DrawLine(L + Vector3.down * band, R + Vector3.down * band);

        // Time-limited dash reach (blue) along current face vector (from boss toward face spot)
        if (target)
        {
            int sign = ((target.position.x - p.x) >= 0f) ? +1 : -1;
            Vector2 faceSpot = new Vector2(target.position.x - sign * stopShortOffset, target.position.y);
            Vector2 toFace   = faceSpot - (Vector2)p;
            Vector2 dir      = toFace.sqrMagnitude > 0f ? toFace.normalized : new Vector2(sign, 0f);
            float reach      = TimeReach;

            Gizmos.color = Color.blue;
            Gizmos.DrawLine(p, p + (Vector3)(dir * reach));
        }

        // Special distance window (thick “dent dots” on X)
        float inner = attackRange * 1.2f;
        float outer = attackRange + TimeReach;
        float dotR  = 0.18f;

        Gizmos.color = Color.green;
        Gizmos.DrawSphere(p + Vector3.right * inner, dotR);
        Gizmos.DrawSphere(p + Vector3.left  * inner, dotR);

        Gizmos.color = Color.red;
        Gizmos.DrawSphere(p + Vector3.right * outer, dotR);
        Gizmos.DrawSphere(p + Vector3.left  * outer, dotR);

        // Stop-short line relative to the player (yellow)
        if (target)
        {
            int sign = ((target.position.x - p.x) >= 0f) ? +1 : -1;
            float stopX = target.position.x - sign * stopShortOffset;
            Vector3 a = new Vector3(stopX, p.y - 0.6f, p.z);
            Vector3 b = new Vector3(stopX, p.y + 0.6f, p.z);
            Gizmos.color = Color.yellow;
            Gizmos.DrawLine(a, b);
        }
    }
}

// ----- File: State_Attack.cs -----
using System.Collections;
using UnityEngine;

public class State_Attack : MonoBehaviour
{
    [Header("References")]
    public W_Base activeWeapon;          // Will get this from children
    public Vector2 attackDir;            // Will calculate this internally

    [Header("Attack Timings")]
    float attackDuration = 0.45f;
    float hitDelay       = 0.15f;

    // cache
    Animator     anim;
    E_Controller controller;

    void Awake()
    {
        anim            = GetComponentInChildren<Animator>();
        controller      = GetComponent<E_Controller>();
        activeWeapon    = GetComponentInChildren<W_Base>();
    }

    void OnEnable()
    {
        anim.SetBool("isAttacking", true); // animator enter

        // Calculate aim direction towards the target provided by the controller
        Transform target = controller.GetTarget();
        if (target)
        {
            attackDir = ((Vector2)target.position - (Vector2)transform.position).normalized;
        }
        else // Fallback if target is lost somehow
        {
            attackDir = new Vector2(anim.GetFloat("idleX"), anim.GetFloat("idleY"));
        }

        // Start the attack routine
        StartCoroutine(AttackRoutine());
    }

    void OnDisable()
    {
        StopAllCoroutines(); // If enemy dies -> stop attack immediately
        anim.SetBool("isAttacking", false); // Exit Attack animation by bool
        controller.SetAttacking(false); // Normal finish
    }

    void Update()
    {
        // Keep idle facing towards attack direction 
        anim.SetFloat("moveX", 0f);
        anim.SetFloat("moveY", 0f);
        anim.SetFloat("idleX", attackDir.x);
        anim.SetFloat("idleY", attackDir.y);
    }

    IEnumerator AttackRoutine()
    {
        // Set animator direction
        anim.SetFloat("atkX", attackDir.x);
        anim.SetFloat("atkY", attackDir.y);

        yield return new WaitForSeconds(hitDelay);
        activeWeapon.Attack(attackDir);
        yield return new WaitForSeconds(attackDuration - hitDelay);

        controller.SetAttacking(false); // Normal finish
    }


}

// ----- File: State_Chase_Boss.cs -----
using UnityEngine;

public class State_Chase_Boss : MonoBehaviour
{
    [Header("Tuning")]
    public float stopBuffer = 0.10f;
    public float yAlignBand = 0.35f;   // shrink |dy| toward this during chase

    float attackRange = 1.6f;
    float specialReach;                // ≈ attackRange + dashMaxDistance

    // Cache
    Rigidbody2D rb;
    Animator anim;
    C_Stats stats;
    I_Controller controller;           // <- use interface so it works with B_Controller / NPC / Enemy

    // Runtime
    Transform target;
    Vector2 velocity, lastMove = Vector2.down;

    void Awake()
    {
        rb         ??= GetComponent<Rigidbody2D>();
        anim       ??= GetComponentInChildren<Animator>();
        stats      ??= GetComponent<C_Stats>();
        controller ??= GetComponent<I_Controller>();

        if (!stats) Debug.LogError($"{name}: C_Stats missing in State_Chase_Boss");
        if (!anim)  Debug.LogError($"{name}: Animator missing in State_Chase_Boss");
        if (controller == null) Debug.LogError($"{name}: I_Controller missing on parent for State_Chase_Boss");
    }

    void OnEnable()  { anim.SetBool("isMoving", false); }
    void OnDisable()
    {
        velocity = Vector2.zero;
        controller?.SetDesiredVelocity(Vector2.zero);
        if (rb) rb.linearVelocity = Vector2.zero;
        anim.SetBool("isMoving", false);
    }

    void Update()
    {
        if (!target)
        {
            velocity = Vector2.zero;
            controller?.SetDesiredVelocity(Vector2.zero);
            UpdateFloats(Vector2.zero);
            anim.SetBool("isMoving", false);
            return;
        }

        Vector2 toTarget  = (Vector2)target.position - (Vector2)transform.position;
        float dx = toTarget.x;
        float dy = toTarget.y;
        float distance = toTarget.magnitude;

        // Horizontal-first chase with vertical alignment bias
        Vector2 desired = Vector2.zero;
        if (Mathf.Abs(dy) > yAlignBand)
        {
            desired.y = Mathf.Sign(dy);
            desired.x = Mathf.Sign(dx) * 0.6f;
        }
        else
        {
            desired.x = Mathf.Sign(dx);
            desired.y = Mathf.Sign(dy) * 0.35f;
        }
        desired = desired.sqrMagnitude > 0f ? desired.normalized : lastMove;

        // Move if outside attack range + buffer
        velocity = (distance > (attackRange + stopBuffer)) ? desired * stats.MS : Vector2.zero;
        bool moving = velocity.sqrMagnitude > 0f;
        anim.SetBool("isMoving", moving);

        controller?.SetDesiredVelocity(velocity);
        UpdateFloats(velocity);
    }

    public void SetTarget(Transform t) => target = t;
    public void SetRanges(float attackRange)
    {
        this.attackRange = attackRange;
        specialReach = attackRange + 2.9f; // default dashMaxDistance (boss attack state clamps exactly)
    }

    void UpdateFloats(Vector2 move)
    {
        if (move.sqrMagnitude > 0f) lastMove = move.normalized;
        anim.SetFloat("moveX", move.x);
        anim.SetFloat("moveY", move.y);
        anim.SetFloat("idleX", lastMove.x);
        anim.SetFloat("idleY", lastMove.y);
    }
}

// ----- File: State_Chase.cs -----
using UnityEngine;

public class State_Chase : MonoBehaviour
{
    [Header("Tuning")]
    [Min(0f)] public float stopBuffer = 0.10f; // used by controller’s axis calc

    // cache
    Animator     anim;
    C_Stats      c_Stats;
    E_Controller controller;

    // runtime
    // Vector2 moveAxis; // Will be calculated in Update
    Vector2 lastMove = Vector2.down;

    void Awake()
    {
        anim        = GetComponent<Animator>();
        c_Stats     = GetComponent<C_Stats>();
        controller  = GetComponent<E_Controller>();
    }

    void OnEnable() {}

    void OnDisable()
    {
        controller.SetDesiredVelocity(Vector2.zero);
        anim.SetBool("isMoving", false);
    }

    void Update()
    {
        // Calculate chase direction
        Vector2 moveAxis = ComputeChaseDir();

        // Calculate and apply movement velocity
        controller.SetDesiredVelocity(moveAxis * c_Stats.MS);

        // Set movement animation
        anim.SetFloat("moveX", moveAxis.x);
        anim.SetFloat("moveY", moveAxis.y);

        // Continue to face the last direction it was moving in
        if (moveAxis.sqrMagnitude > 0f) lastMove = moveAxis;
        anim.SetFloat("idleX", lastMove.x);
        anim.SetFloat("idleY", lastMove.y);

        // Optional: derive isMoving from axis (keeps old visuals)
        bool moving = moveAxis.sqrMagnitude > 0f;
        anim.SetBool("isMoving", moving);
    }

    Vector2 ComputeChaseDir()
    {
        Transform target = controller.GetTarget();
        if (!target) return Vector2.zero;

        Vector2 to = (Vector2)target.position - (Vector2)transform.position;
        float dist = to.magnitude;
        if (dist <= 0.000001f) return Vector2.zero;

        float stop = controller.GetAttackRange() + stopBuffer;
        return (dist > stop) ? (to / dist) : Vector2.zero; // normalized or zero if within stop band
    }
}

