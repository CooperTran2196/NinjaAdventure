 
// ----- File: E_Combat.cs ----- 
using System;
using System.Collections;
using UnityEngine;

public class E_Combat : MonoBehaviour
{
    [Header("References")]
    SpriteRenderer sprite;
    Animator animator;

    public E_Stats e_stats;
    public E_Movement e_movement;
    public C_Health e_health;
    public W_Base activeWeapon;

    [Header("AI")]
    public LayerMask playerLayer;
    [Min(1.3f)] public float attackRange = 1.3f;
    [Min(0.5f)] public float thinkInterval = 0.5f;

    [Header("Attack")]
    [Header("ALWAYS matched full clip length (0.45)")]
    public float attackDuration = 0.45f;
    [Header("ALWAYS set when the hit happens (0.15)")]
    public float hitDelay = 0.15f;
    public bool lockDuringAttack = true;

    [Header("Debug")]
    [SerializeField] bool autoKill;

    // Quick state check
    public bool IsAlive => e_stats.currentHP > 0;

    bool isAttacking;
    float contactTimer;   // for collision damage
    float cooldownTimer;  // for attacking cooldown

    void Awake()
    {
        sprite          ??= GetComponent<SpriteRenderer>();
        animator        ??= GetComponent<Animator>();

        e_stats         ??= GetComponent<E_Stats>();
        e_movement      ??= GetComponent<E_Movement>();
        e_health        ??= GetComponent<C_Health>();
        activeWeapon    ??= GetComponentInChildren<W_Melee>();

        if (!sprite) Debug.LogError($"{name}: SpriteRenderer missing.");
        if (!animator) Debug.LogError($"{name}: Animator missing.");

        if (!e_stats) Debug.LogError($"{name}: E_Stats missing.");
        if (!e_movement) Debug.LogError($"{name}: E_Movement missing.");
        if (!e_health) Debug.LogError($"{name}: C_Health missing.");
        if (!activeWeapon) Debug.LogError($"{name}: C_Melee missing.");
    }

    void OnEnable()
    {
        StartCoroutine(ThinkLoop());
        e_health.OnDied += Die;
    }


    void OnDisable()
    {
        e_health.OnDied -= Die;
    }

    void Update()
    {
        if (autoKill) { autoKill = false; e_health.ChangeHealth(-e_stats.maxHP); }
        if (cooldownTimer > 0f) cooldownTimer -= Time.deltaTime;
    }

    IEnumerator ThinkLoop()
    {
        var wait = new WaitForSeconds(thinkInterval);

        while (true)
        {
            if (!IsAlive) yield break;

            if (!isAttacking)
            {
                bool inAttackRange = Physics2D.OverlapCircle((Vector2)transform.position, attackRange, playerLayer);

                if (lockDuringAttack)
                {
                    // Normal mode: Idle in place if player is still in range
                    bool shouldHold = inAttackRange && cooldownTimer > 0f;
                    e_movement.SetHoldInRange(shouldHold);
                }
                else
                {
                    // Hard mode: Enemies never hold between attack
                    e_movement.SetHoldInRange(false);
                }
                // If close enough and off cooldown, begin an attack
                if (inAttackRange && cooldownTimer <= 0f)
                    StartCoroutine(AttackRoutine());
            }
            yield return wait;
        }
    }

    // Collision Damage
    void OnCollisionStay2D(Collision2D collision)
    {
        if (!IsAlive) return;

        // Count down using physics timestep
        if (contactTimer > 0f)
        {
            contactTimer -= Time.fixedDeltaTime;
            return;
        }
        var playerHealth = collision.collider.GetComponent<C_Health>();
        if (playerHealth == null || !playerHealth.IsAlive) return; // Only damage a live player
        playerHealth.ChangeHealth(-e_stats.collisionDamage); //Apply damage
        contactTimer = e_stats.collisionTick; // reset tick window
    }


    IEnumerator AttackRoutine()
    {
        isAttacking = true;
        animator.SetBool("isAttacking", true);

        // Aim the directional attack
        var dir = e_movement.lastMove;
        animator.SetFloat("atkX", dir.x);
        animator.SetFloat("atkY", dir.y);

        // Delay -> Attack -> recover
        yield return new WaitForSeconds(hitDelay);
        // Placeholder
        activeWeapon?.Attack();
        yield return new WaitForSeconds(attackDuration - hitDelay);
        
        // Decide keep chasing/idle based on lockDuringAttack (MODE)
        if (lockDuringAttack)
        {
            bool stillInRange = Physics2D.OverlapCircle((Vector2)transform.position, attackRange, playerLayer);
            e_movement.SetHoldInRange(stillInRange);
        }
        else
        {
            e_movement.SetHoldInRange(false);
        }

        isAttacking = false;
        animator.SetBool("isAttacking", false);

        cooldownTimer = e_stats.attackCooldown;
    }

    void Die()
    {
        e_movement.SetDisabled(true);
        animator.SetTrigger("Die");
    }

    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0f, 0f, 0.9f); // red attack ring
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}
 
// ----- File: E_Movement.cs ----- 
using System;
using UnityEngine;

public class E_Movement : MonoBehaviour
{
    [Header("References")]
    SpriteRenderer sprite;
    Rigidbody2D rb;
    Animator animator;
    
    public E_Stats e_stats;
    public E_Combat e_combat;

    [Header("Detection (OverlapCircle)")]
    public LayerMask playerLayer;
    [Min(3f)] public float detectionRadius = 3f;

    [Header("Facing / Animator")]
    public Vector2 lastMove = Vector2.down;

    // Runtime state
    Transform target;
    bool disabled;
    bool holdInRange;
    Vector2 moveAxis;
    Vector2 velocity;
    Vector2 knockback;

    const float MIN_DISTANCE = 0.0001f;
    
    void Awake()
    {
        sprite      ??= GetComponent<SpriteRenderer>();
        rb          ??= GetComponent<Rigidbody2D>();
        animator    ??= GetComponent<Animator>();

        e_stats     ??= GetComponent<E_Stats>();
        e_combat    ??= GetComponent<E_Combat>();
        

        if (sprite      == null) Debug.LogError($"{name}: SpriteRenderer missing.");
        if (rb          == null) Debug.LogError($"{name}: Rigidbody2D missing.");
        if (animator    == null) Debug.LogError($"{name}: Animator missing.");
        
        if (e_stats == null) Debug.LogError($"{name}: E_Stats missing.");
        if (e_combat    == null) Debug.LogError($"{name}: E_Combat missing.");
    }

    void Update()
    {
        Chase();
        C_Anim.UpdateAnimDirections(animator, animator.GetBool("isAttacking"), moveAxis, lastMove, MIN_DISTANCE);
    }

    void FixedUpdate()
    {
        Vector2 final = velocity + knockback;
        rb.linearVelocity = final; // replace linearVelocity

        if (knockback.sqrMagnitude > 0f)
        {
            float step = (e_stats ? e_stats.KR : 0f) * Time.fixedDeltaTime;
            knockback = Vector2.MoveTowards(knockback, Vector2.zero, step);
        }
    }

    void Chase()
    {
        // Setup target if player comes close
        var hit = Physics2D.OverlapCircle((Vector2)transform.position, detectionRadius, playerLayer);
        target = hit ? hit.transform : null;

        if (disabled)
        {
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            return;
        }

        if (target == null)
        {
            moveAxis = Vector2.zero;
        }
        else
        {
            Vector2 to = (Vector2)target.position - (Vector2)transform.position;
            bool hasDir = to.sqrMagnitude > (MIN_DISTANCE * MIN_DISTANCE);
            if (hasDir) lastMove = to.normalized;

            // If holding then don't create intent, otherwise face & move toward target
            moveAxis = (holdInRange || !hasDir) ? Vector2.zero : lastMove;
        }

        // Velocity valve
        bool attacking = animator.GetBool("isAttacking");
        // Block velocity when disabled, holding, or attacking
        bool valveClosed = disabled || holdInRange || (attacking && e_combat.lockDuringAttack);

        Vector2 intendedVelocity = moveAxis * e_stats.MS;
        velocity = valveClosed ? Vector2.zero : intendedVelocity;
    }

    // Freeze movement/anim immediately
    public void SetDisabled(bool isDisabled)
    {
        disabled = isDisabled;
        if (isDisabled)
        {
            holdInRange = false;
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            rb.linearVelocity = Vector2.zero; // immediate stop
            animator.SetBool("isMoving", false);
            animator.SetBool("isIdle", false);
        }
    }

    public void ReceiveKnockback(Vector2 force) { knockback += force; }

    // Combat asks to idle-in-place during cooldown
    public void SetHoldInRange(bool v) => holdInRange = v;

    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0.55f, 0f, 0.9f); // orange detection ring
        Gizmos.DrawWireSphere(transform.position, detectionRadius);
    }
}
 
// ----- File: E_Stats.cs ----- 
using UnityEngine;

[DisallowMultipleComponent]
public class E_Stats : MonoBehaviour
{
    [Header("Stats")]
    public int AD = 1; // Attack Damage
    public int AP = 0; // Ability Power
    public float MS = 5f; // Move Speed

    public int maxHP = 10;
    public int currentHP = 10;
    public int AR = 0; // Armor
    public int MR = 0; // Magic Resist
    public float KR = 10f; // knockback Resist

    [Header("Combat")]
    public float attackCooldown = 1.2f;
    public int   collisionDamage = 1;   // per-enemy
    public float collisionTick   = 0.5f; // seconds between ticks while touching

    [Header("Placeholders")]
    public float knockbackForce = 0f;
    public float stunTime = 0f;
}
 
