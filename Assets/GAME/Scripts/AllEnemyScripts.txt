// ----- File: E_Combat.cs -----
using System;
using System.Collections;
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
[RequireComponent(typeof(Animator))]

[DisallowMultipleComponent]

public class E_Combat : MonoBehaviour
{
    [Header("References")]
    SpriteRenderer sr;
    Animator anim;

    C_Stats c_Stats;
    C_State c_State;
    E_Movement e_Movement;
    C_Health e_Health;
    public W_Base activeWeapon;
    C_Wander c_Wander;

    [Header("AI")]
    public LayerMask playerLayer;
    [Min(1.3f)] public float attackRange = 1.3f;
    [Min(0.5f)] public float thinkInterval = 0.5f;

    [Header("Attack")]
    [Header("ALWAYS matched full clip length (0.45)")]
    public float attackDuration = 0.45f;
    [Header("ALWAYS set when the hit happens (0.15)")]
    public float hitDelay = 0.15f;

    [Header("Debug")]
    [SerializeField] bool autoKill;

    // Quick state check
    public bool isAttacking { get; private set; }
    // Removed IsAlive; use c_State.Is(ActorState.Dead) as single source of truth
    const float MIN_DISTANCE = 0.0001f;
    float contactTimer;   // for collision damage
    float cooldownTimer;  // for attacking cooldown

    void Awake()
    {
        sr           ??= GetComponent<SpriteRenderer>();
        anim         ??= GetComponent<Animator>();

        c_Stats      ??= GetComponent<C_Stats>();
        c_State      ??= GetComponent<C_State>();
        e_Movement   ??= GetComponent<E_Movement>();
        e_Health     ??= GetComponent<C_Health>();
        activeWeapon ??= GetComponentInChildren<W_Melee>();
        c_Wander     ??= GetComponent<C_Wander>();

        if (!sr)            Debug.LogError($"{name}: SpriteRenderer in E_Combat missing.");
        if (!anim)          Debug.LogError($"{name}: Animator in E_Combat missing.");

        if (!c_Stats)       Debug.LogError($"{name}: C_Stats in E_Combat missing.");
        if (!e_Movement)    Debug.LogError($"{name}: E_Movement in E_Combat missing.");
        if (!e_Health)      Debug.LogError($"{name}: C_Health in E_Combat missing.");
        if (!activeWeapon)  Debug.LogError($"{name}: W_Melee in E_Combat missing.");
        // c_Wander optional: only log verbose if enemy expected to wander? (skip error)
    }

    void OnEnable()
    {
        StartCoroutine(ThinkLoop());
    }

    void Update()
    {
        if (autoKill) { autoKill = false; e_Health.ChangeHealth(-c_Stats.maxHP); }
        if (cooldownTimer > 0f) cooldownTimer -= Time.deltaTime;
    }

    IEnumerator ThinkLoop()
    {
        var wait = new WaitForSeconds(thinkInterval);

        while (true)
        {
            if (c_State.Is(C_State.ActorState.Dead)) yield break;

            if (!isAttacking)
            {
                // Check if player is in range
                bool inAttackRange = Physics2D.OverlapCircle((Vector2)transform.position, attackRange, playerLayer);

                // Decide if should hold position (idle) or chase
                bool shouldHold = inAttackRange && cooldownTimer > 0f && c_State.lockMoveWhileAttacking;
                e_Movement.SetHoldInRange(shouldHold);

                // If close enough and off cooldown, begin an attack
                if (inAttackRange && cooldownTimer <= 0f)
                    StartCoroutine(AttackRoutine());
            }
            yield return wait;
        }
    }

    // Collision Damage
    void OnCollisionStay2D(Collision2D collision)
    {
        if (c_State.Is(C_State.ActorState.Dead)) return;

        // Filter to only player layer
        if ((playerLayer.value & (1 << collision.collider.gameObject.layer)) == 0)
            return;
        // Count down using physics timestep
        if (contactTimer > 0f)
        {
            contactTimer -= Time.fixedDeltaTime;
            return;
        }
        var playerHealth = collision.collider.GetComponent<C_Health>();
        if (playerHealth == null || !playerHealth.IsAlive) return; // Only damage a live player
        playerHealth.ChangeHealth(-c_Stats.collisionDamage); //Apply damage
        contactTimer = c_Stats.collisionTick; // reset tick window
    }


    IEnumerator AttackRoutine()
    {
        isAttacking = true;

        // CONTINUOUS facing from player position at attack start (no lastMove / no snap)
        Vector2 dir = ReadAimToPlayer();

        // Set facing direction
        c_State.SetAttackDirection(dir);

        // Delay -> Attack -> recover
        yield return new WaitForSeconds(hitDelay);
        // Placeholder
        activeWeapon?.Attack(dir);
        yield return new WaitForSeconds(attackDuration - hitDelay);

        // Decide keep chasing/idle based on lockDuringAttack (MODE)
        bool lockMoveFlag = (c_State && c_State.lockMoveWhileAttacking);
        bool stillInRange = Physics2D.OverlapCircle((Vector2)transform.position, attackRange, playerLayer);
        e_Movement.SetHoldInRange(lockMoveFlag && stillInRange);

        isAttacking = false;

        cooldownTimer = c_Stats.attackCooldown;
    }

    Vector2 ReadAimToPlayer()
    {
        var player = GameObject.FindGameObjectWithTag("Player");
        if (!player) return Vector2.down;
        Vector2 d = (Vector2)(player.transform.position - transform.position);
        return (d.sqrMagnitude > MIN_DISTANCE) ? d.normalized : Vector2.down;
    }

    // Debug: show attack range
    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0f, 0f, 0.9f); // red attack ring
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}

// ----- File: E_HealthBarSlider.cs -----
// File: E_HealthBarSlider.cs  (enemy-only, green-only)
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(CanvasGroup))]
[DisallowMultipleComponent]

public class E_HealthBarSlider : MonoBehaviour
{
    [Header("References")]
    CanvasGroup cg;

    public C_Health e_Health; // Health in parent
    public Slider   slider;   // slider in child

    [Header("World Positioning")]
    public Vector3 worldOffset = new Vector3(0f, 1.5f, 0f);

    [Header("Visibility")]
    public float visibleTime = 2f;   // auto-hide delay
    public bool  startHidden = true; // start invisible until first event

    float hideTimer;

    void Awake()
    {
        cg       ??= GetComponent<CanvasGroup>();
        e_Health ??= GetComponentInParent<C_Health>();

        if (!e_Health) Debug.LogError($"{name}: C_Health in E_HealthBarSlider is missing.", this);
        if (!slider)   Debug.LogError($"{name}: Slider in E_HealthBarSlider is missing.", this);
    }

    void OnEnable()
    {
        var s           = e_Health.c_Stats;      // current/max HP live here
        slider.maxValue = s.maxHP;     // make slider track the true max
        slider.value    = s.currentHP; // initialize to current

        if (startHidden) cg.alpha = 0f;

        e_Health.OnDamaged += OnDamaged;
        e_Health.OnHealed  += OnHealed;
        e_Health.OnDied    += OnDied;
    }

    void OnDisable()
    {
        e_Health.OnDamaged -= OnDamaged;
        e_Health.OnHealed  -= OnHealed;
        e_Health.OnDied    -= OnDied;
    }

    // LateUpdate to ensure it runs after all movement
    void LateUpdate()
    {
        // follow owner
        transform.position = e_Health.transform.position + worldOffset;

        // handle fade-out timer
        if (hideTimer > 0f)
        {
            hideTimer -= Time.deltaTime;
            if (hideTimer <= 0f) cg.alpha = 0f;
        }
    }

    // Event handlers
    void OnDamaged(int amount)
    {
        slider.value = e_Health.c_Stats.currentHP;
        Show();
    }

    void OnHealed(int amount)
    {
        slider.value = e_Health.c_Stats.currentHP;
        Show();
    }

    void OnDied()
    {
        cg.alpha = 0f; // death visuals handled elsewhere
    }

    void Show()
    {
        cg.alpha = 1f;
        hideTimer = visibleTime;
    }
}

// ----- File: E_Movement.cs -----
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(Animator))]
[RequireComponent(typeof(C_Stats))]
[RequireComponent(typeof(C_State))]
[RequireComponent(typeof(E_Combat))]
[RequireComponent(typeof(C_Wander))]
[DisallowMultipleComponent]

public class E_Movement : MonoBehaviour
{
    [Header("References")]
    SpriteRenderer sprite;
    Rigidbody2D rb;
    Animator animator;

    C_Stats c_Stats;
    C_State c_State;
    E_Combat e_Combat;
    C_Wander c_Wander;

    [Header("Detection (OverlapCircle)")]
    public LayerMask playerLayer;
    [Min(3f)] public float detectionRadius = 3f;

    [Header("Facing / Animator")]
    public Vector2 lastMove = Vector2.down;

    // Runtime state
    Transform target;
    bool disabled;
    bool holdInRange;
    Vector2 moveAxis;
    Vector2 velocity;
    Vector2 knockback;

    const float MIN_DISTANCE = 0.000001f;

    void Awake()
    {
        sprite   ??= GetComponent<SpriteRenderer>();
        rb       ??= GetComponent<Rigidbody2D>();
        animator ??= GetComponent<Animator>();

        c_Stats  ??= GetComponent<C_Stats>();
        c_State  ??= GetComponent<C_State>();
        e_Combat ??= GetComponent<E_Combat>();
        c_Wander ??= GetComponent<C_Wander>();

        if (!sprite)   Debug.LogError($"{name}: SpriteRenderer in E_Movement is missing.");
        if (!rb)       Debug.LogError($"{name}: Rigidbody2D in E_Movement is missing.");
        if (!animator) Debug.LogError($"{name}: Animator in E_Movement is missing.");

        if (!c_Stats)  Debug.LogError($"{name}: C_Stats in E_Movement is missing.");
        if (!c_State)  Debug.LogError($"{name}: C_State in E_Movement is missing.");
        if (!e_Combat) Debug.LogError($"{name}: E_Combat in E_Movement is missing.");
        if (!c_Wander) Debug.LogError($"{name}: C_Wander in E_Movement is missing.");
    }

    void Update()
    {
        Chase();
        
        // Preserve lastMove during pauses/idle
        if (c_State.Is(C_State.ActorState.Attack))
        {
            lastMove = c_State.GetAttackDirection();
        }
        c_State.UpdateAnimDirections(moveAxis, lastMove);
    }

    void FixedUpdate()
    {
        // Skip movement if wandering
        if (c_State.Is(C_State.ActorState.Wander)) return;

        // Apply movement + knockback
        Vector2 final = velocity + knockback;
        rb.linearVelocity = final; // replace linearVelocity

        if (knockback.sqrMagnitude > 0f)
        {
            float step = c_Stats.KR * Time.fixedDeltaTime;
            knockback = Vector2.MoveTowards(knockback, Vector2.zero, step);
        }
    }

    void Chase()
    {
        // If dead, ensure everything stays stopped and wander cannot reactivate
        if (c_State.Is(C_State.ActorState.Dead))
        {
            if (c_Wander.enabled) c_Wander.enabled = false;
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            rb.linearVelocity = Vector2.zero;
            return;
        }

        // Setup target if player comes close
        var hit = Physics2D.OverlapCircle((Vector2)transform.position, detectionRadius, playerLayer);
        target = hit ? hit.transform : null;

        // Toggle wandering by detection
        if (target != null)
        {
            c_Wander.enabled = false; // disable wander while chasing
        }
        else
        {
            c_Wander.enabled = true; // re-enable wander when no target
        }

        if (disabled)
        {
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            return;
        }

        if (target == null)
        {
            moveAxis = Vector2.zero;
        }
        else
        {
            Vector2 to = (Vector2)target.position - (Vector2)transform.position;
            bool hasDir = to.sqrMagnitude > MIN_DISTANCE;
            if (hasDir) lastMove = to.normalized;

            // If holding then don't create intent, otherwise face & move toward target
            moveAxis = (holdInRange || !hasDir) ? Vector2.zero : lastMove;
        }

        // Velocity valve
        bool valveClosed = disabled || holdInRange || (c_State != null && c_State.CheckIsBusy());
        Vector2 intendedVelocity = moveAxis * c_Stats.MS;
        velocity = valveClosed ? Vector2.zero : intendedVelocity;
    }

    // Freeze movement/anim immediately
    public void SetDisabled(bool isDisabled)
    {
        disabled = isDisabled;
        if (isDisabled)
        {
            holdInRange = false;
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            rb.linearVelocity = Vector2.zero; // immediate stop
        }
    }

    // External knockback request
    public void ReceiveKnockback(Vector2 force) { knockback += force; }

    // Combat asks to idle-in-place during cooldown
    public void SetHoldInRange(bool v) => holdInRange = v;


    // Debug: show detection radius
    void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0.55f, 0f, 0.9f); // orange detection ring
        Gizmos.DrawWireSphere(transform.position, detectionRadius);
    }
}

// ----- File: E_Reward.cs -----
using UnityEngine;

[DisallowMultipleComponent]

public class E_Reward : MonoBehaviour
{
    [Header("Rewards")]
    public int expReward = 10; // tweak per enemy prefab

    C_Health c_Health;
    static P_Exp p_Exp;

    void Awake()
    {
        c_Health ??= GetComponentInParent<C_Health>();
        if (!p_Exp) p_Exp = FindFirstObjectByType<P_Exp>();

        if (!c_Health) Debug.LogError($"{name}: C_Health in E_Reward missing.", this);
        if (!p_Exp) Debug.LogError($"{name}: P_Exp not found in scene.", this);
    }

    void OnEnable()
    {
        c_Health.OnDied += HandleDied;
    }

    void OnDisable()
    {
        c_Health.OnDied -= HandleDied;
    }

    void HandleDied()
    {
        p_Exp?.AddXP(expReward);
    }
}

