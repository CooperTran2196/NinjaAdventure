 
// ----- File: P_Combat.cs ----- 
using System;
using System.Collections;
using UnityEngine;

public class P_Combat : MonoBehaviour
{
    [Header("References")]
    SpriteRenderer sprite;
    Animator animator;
    P_InputActions input;

    public P_Stats     p_Stats;
    public P_Movement  p_Movement;
    public C_Health    p_Health;
    public W_Base      activeWeapon;
    
    [Header("Attack")]
    [Header("ALWAYS matched full clip length (0.45)")]
    public float attackDuration = 0.45f;
    [Header("ALWAYS set when the hit happens (0.15)")]
    public float hitDelay = 0.15f;
    public bool lockDuringAttack = true;

    [Header("Debug")]
    [SerializeField] bool autoKill;

    Vector2 aimDir = Vector2.down;
    const float MIN_DISTANCE = 0.0001f;
    float cooldownTimer;
    public bool IsAttacking { get; private set; }

    // Quick state check
    public bool IsAlive => p_Stats.currentHP > 0;

    void Awake()
    {
        sprite ??= GetComponent<SpriteRenderer>();
        animator ??= GetComponent<Animator>();
        input ??= new P_InputActions();
        
        p_Stats ??= GetComponent<P_Stats>();
        p_Movement ??= GetComponent<P_Movement>();
        p_Health ??= GetComponent<C_Health>();
        activeWeapon ??= GetComponentInChildren<W_Melee>();

        
        if (!sprite) Debug.LogWarning($"{name}: SpriteRenderer in P_Combat missing.");
        if (!animator) Debug.LogError($"{name}: Animator in P_Combat missing.");

        if (!p_Stats) Debug.LogError($"{name}: P_Stats in P_Combat missing.");
        if (!p_Movement) Debug.LogError($"{name}: P_Movement in P_Combat missing.");
        if (!p_Health) Debug.LogError($"{name}: C_Health in P_Combat missing.");
        if (!activeWeapon) Debug.LogError($"{name}: W_Melee in P_Combat missing.");

        animator.SetFloat("atkX", 0f);
        animator.SetFloat("atkY", -1f);
    }

    void OnEnable()
    {
        input?.Enable();
        p_Health.OnDied += Die;
    }

    void OnDisable()
    {
        input?.Disable();
        p_Health.OnDied -= Die;
    }

    void Update()
    {
        Vector2 raw = input.Player.Move.ReadValue<Vector2>();
        if (raw.sqrMagnitude > MIN_DISTANCE) aimDir = raw.normalized;
        if (input.Player.Attack.triggered) RequestAttack();

        if (autoKill) { autoKill = false; p_Health.ChangeHealth(-p_Stats.maxHP); }

        if (cooldownTimer > 0f) cooldownTimer -= Time.deltaTime;
    }

    public void RequestAttack()
    {
        if (!IsAlive || cooldownTimer > 0f) return;

        cooldownTimer = p_Stats.attackCooldown;

        // Face once at attack start
        animator.SetFloat("atkX", aimDir.x);
        animator.SetFloat("atkY", aimDir.y);
        StartCoroutine(AttackRoutine());
    }

    IEnumerator AttackRoutine()
    {
        // STATE: Attack START
        IsAttacking = true;

        // Delay -> Attack -> Recover
        yield return new WaitForSeconds(hitDelay);
        activeWeapon?.Attack();
        yield return new WaitForSeconds(attackDuration - hitDelay);

        // STATE: Attack END
        IsAttacking = false;
    }

    void Die()
    {
        p_Movement.SetDisabled(true);
        animator.SetTrigger("Die");
    }
}
 
// ----- File: P_Movement.cs ----- 
using System;
using UnityEngine;

public class P_Movement : MonoBehaviour
{
    [Header("References")]
    Rigidbody2D rb;
    Animator animator;
    P_InputActions input;

    public P_Stats p_Stats;
    public P_Combat p_Combat;
    public C_Dodge c_Dodge;
    public C_State c_State;

    [Header("Facing / Animator")]
    public Vector2 lastMove = Vector2.down; // Default facing down

    // Runtime state
    bool disabled;      // When true, movement/animation stops
    Vector2 moveAxis;   // Desired direction of travel
    Vector2 velocity;   // Final velocity applied to Rigidbody2D.linearVelocity
    Vector2 knockback;

    const float MIN_DISTANCE = 0.0001f;

    void Awake()
    {
        rb ??= GetComponent<Rigidbody2D>();
        animator ??= GetComponent<Animator>();
        input ??= new P_InputActions();

        p_Stats ??= GetComponent<P_Stats>();
        p_Combat ??= GetComponent<P_Combat>();
        c_Dodge ??= GetComponent<C_Dodge>();
        c_State ??= GetComponent<C_State>();

        if (!rb) Debug.LogError($"{name}: Rigidbody2D in P_Movement missing.");
        if (!animator) Debug.LogError($"{name}: Animator in P_Movement missing.");
        if (!p_Stats) Debug.LogError($"{name}: P_Stats in P_Movement missing.");
        if (!p_Combat) Debug.LogError($"{name}: P_Combat in P_Movement missing.");
        if (!c_Dodge) Debug.LogError($"{name}: C_Dodge in P_Movement missing.");
        if (!c_State) Debug.LogError($"{name}: C_State in P_Movement missing.");

        lastMove = Vector2.down;
        animator?.SetFloat("moveX", 0f);
        animator?.SetFloat("moveY", -1f);
    }

    void OnEnable() => input.Enable();
    void OnDisable() => input.Disable();

    void Update()
    {
        // Normalize to avoid diagonal speed advantage; also gives clean 4/8-way
        // If raw is near zero, normalized will be (0,0)
        Vector2 raw = input.Player.Move.ReadValue<Vector2>();
        Vector2 desired = raw.sqrMagnitude > MIN_DISTANCE ? raw.normalized : Vector2.zero;

        SetMoveAxis(desired);
        
        bool busy = c_State != null && c_State.IsBusy;
        C_Anim.UpdateAnimDirections(animator, busy, moveAxis, lastMove, MIN_DISTANCE);
    }


    void FixedUpdate()
    {
        Vector2 forced = (c_Dodge != null) ? c_Dodge.ForcedVelocity : Vector2.zero;
        Vector2 baseVel = (forced != Vector2.zero) ? forced : velocity;
        Vector2 final   = baseVel + knockback;
        rb.linearVelocity = final;


        if (knockback.sqrMagnitude > 0f)
        {
            float step = (p_Stats ? p_Stats.KR : 0f) * Time.fixedDeltaTime;
            knockback = Vector2.MoveTowards(knockback, Vector2.zero, step);
        }
    }


    void SetMoveAxis(Vector2 v)
    {
        if (disabled)
        {
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            return;
        }

        // Only fire direction event if direction actually changed.
        if (moveAxis != v && v.sqrMagnitude > MIN_DISTANCE)
        {
            lastMove = v; // Idle facing uses latest non-zero direction
        }

        moveAxis = v;

        // Velocity valve: stop only if attacking AND lockDuringAttack
        // Read attack-state from Animator
        bool attacking = animator.GetBool("isAttacking");
        // Valve is closed when disabled OR lockDuringAttack
        bool valveClosed = disabled || (attacking && p_Combat.lockDuringAttack);
        // If valve is closed, stop; otherwise apply intended velocity
        Vector2 intendedVelocity = moveAxis * p_Stats.MS;
        velocity = valveClosed ? Vector2.zero : intendedVelocity;
    }

    public void SetDisabled(bool isDisabled)
    {
        disabled = isDisabled;
        if (isDisabled)
        {
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            rb.linearVelocity = Vector2.zero; // immediate stop
        }
    }

    public void ReceiveKnockback(Vector2 force) => knockback += force;

}
 
// ----- File: P_Stats.cs ----- 
using UnityEngine;

[DisallowMultipleComponent]
public class P_Stats : MonoBehaviour
{
    [Header("Stats")]
    public int AD = 1; // Attack Damage
    public int AP = 0; // Ability Power
    public float MS = 5f; // Move Speed

    public int maxHP = 10;
    public int currentHP = 10;
    public int AR = 0; // Armor
    public int MR = 0; // Magic Resist
    public float KR = 10f; // knockback Resist

    [Header("Combat")]
    public float attackCooldown = 1.2f;

    [Header("Dodge")]
    public float dodgeSpeed = 11f;      // units/second
    public float dodgeDistance = 2.0f;  // units (â‰ˆ tiles)
    public float dodgeCooldown = 0.45f; // seconds

    [Header("Placeholders")]
    public float knockbackForce = 0f;
    public float stunTime = 0f;
}
 
