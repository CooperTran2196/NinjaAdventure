// ----- File: P_Combat.cs -----
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.InputSystem;

public class P_Combat : MonoBehaviour
{
    [Header("References")]
    SpriteRenderer sprite;
    Animator animator;
    P_InputActions input;

    C_Stats     c_Stats;
    C_State     c_State;
    P_Movement  p_Movement;
    C_Health    c_Health;
    
    [Header("Weapons (Player can hold 3)")]
    public W_Melee  meleeWeapon;
    public W_Ranged rangedWeapon;
    public W_Base   magicWeapon;
    
    [Header("Attack")]
    [Header("ALWAYS matched full clip length (0.45)")]
    public float attackDuration = 0.45f;
    [Header("ALWAYS set when the hit happens (0.15)")]
    public float hitDelay = 0.15f;

    [Header("Debug")]
    [SerializeField] bool autoKill;

    Vector2 attackDir = Vector2.down; // default when starting the game
    const float MIN_DISTANCE = 0.0001f;
    float cooldownTimer;
    public bool isAttacking { get; private set; }

    // Quick state check
    public bool IsAlive => c_Stats.currentHP > 0;

    void Awake()
    {
        sprite ??= GetComponent<SpriteRenderer>();
        animator ??= GetComponent<Animator>();
        input ??= new P_InputActions();
        
        c_Stats ??= GetComponent<C_Stats>();
        c_State ??= GetComponent<C_State>();
        p_Movement ??= GetComponent<P_Movement>();
        c_Health ??= GetComponent<C_Health>();

        meleeWeapon  ??= GetComponentInChildren<W_Melee>();
        rangedWeapon ??= GetComponentInChildren<W_Ranged>();
        magicWeapon  ??= null; // placeholder only

        
        if (!sprite) Debug.LogWarning($"{name}: SpriteRenderer in P_Combat missing.");
        if (!animator) Debug.LogError($"{name}: Animator in P_Combat missing.");

        if (!c_Stats) Debug.LogError($"{name}: P_Stats in P_Combat missing.");
        
        if (!p_Movement) Debug.LogError($"{name}: P_Movement in P_Combat missing.");
        if (!c_Health) Debug.LogError($"{name}: C_Health in P_Combat missing.");
    }

    void OnEnable()
    {
        input?.Enable();
    }

    void OnDisable()
    {
        input?.Disable();
    }

    void Update()
    {
        // Read aim from MOUSE
        Vector2 mouseAim = ReadMouseAim();
        if (mouseAim.sqrMagnitude > MIN_DISTANCE) attackDir = mouseAim;

        // Inputs: Left Mouse  -> Melee, Right Mouse -> Ranged
        if (input.Player.MeleeAttack.triggered)  RequestAttack(meleeWeapon);
        if (input.Player.RangedAttack.triggered) RequestAttack(rangedWeapon);

        if (autoKill) { autoKill = false; c_Health.ChangeHealth(-c_Stats.maxHP); }

        if (cooldownTimer > 0f) cooldownTimer -= Time.deltaTime;
    }

    public void RequestAttack(W_Base weapon)
    {
        if (!IsAlive || cooldownTimer > 0f) return;

        cooldownTimer = c_Stats.attackCooldown;

        // Face once at attack start
        c_State.SetAttackDirection(attackDir);

        
        StartCoroutine(AttackRoutine(weapon));
    }

    IEnumerator AttackRoutine(W_Base weapon)
    {
        // STATE: Attack START
        isAttacking = true;

        // Delay -> Attack -> Recover
        yield return new WaitForSeconds(hitDelay);
        weapon.Attack(attackDir);
        yield return new WaitForSeconds(attackDuration - hitDelay);

        // STATE: Attack END
        isAttacking = false;
    }

    Vector2 ReadMouseAim()
    {
        // return previous aim if no camera/mouse
        if (!Camera.main || Mouse.current == null)
        {
            Debug.LogError("P_Combat: No main camera or mouse found for aiming.");
            return attackDir;
        }

        // screen-space mouse position
            Vector2 m = Mouse.current.position.ReadValue();

        // z distance from camera to actor for ScreenToWorldPoint
        float z = Mathf.Abs(Camera.main.transform.position.z - transform.position.z);

        // mouse position in world space at actor depth
        Vector3 mw = Camera.main.ScreenToWorldPoint(new Vector3(m.x, m.y, z));

        // vector from actor to mouse
        Vector2 d = (Vector2)(mw - transform.position);

        // return normalized direction if significant, else preserve aim
        return (d.sqrMagnitude > MIN_DISTANCE) ? d.normalized : attackDir;
    }
}

// ----- File: P_Exp.cs -----
using UnityEngine;
using System;

[DisallowMultipleComponent]
public class P_Exp : MonoBehaviour
{
    [Header("Independent component to manage Player's XP, Level, and Skill Points")]
    [Header("Linear XP curve")]
    public int level = 1;
    public int currentXP = 0;
    public int skillPoints = 0;
    public int xpBase = 60;      // L1 -> L2
    public int xpStep = 30;      // linear add per level
    public int skillPointsPerLevel = 2;

    [Header("Debug")]
    public int debugXPAmount = 20;

    public event Action<int>        OnLevelUp;
    public event Action<int,int>    OnXPChanged;
    public event Action<int>        OnSPChanged;

    void Start()
    {
        OnXPChanged?.Invoke(currentXP, GetXPRequiredForNext());
    }

    public void AddDebugXP()
    {
        AddXP(debugXPAmount);
    }

    // Add XP and handle level up
    public void AddXP(int amount)
    {
        if (amount <= 0) return;

        // Add XP and check for level up
        currentXP += amount;
        int req = GetXPRequiredForNext();

        // Level up while enough XP for next level
        while (currentXP >= req)
        {
            currentXP -= req;
            level++;
            skillPoints += skillPointsPerLevel;

            OnLevelUp?.Invoke(level);
            OnSPChanged?.Invoke(skillPoints);

            req = GetXPRequiredForNext();
        }

        OnXPChanged?.Invoke(currentXP, req);
    }

    // Return true if successfully spent points
    public bool TrySpendSkillPoints(int amount)
    {
        // return false if not enough points
        if (amount <= 0) return false;
        if (skillPoints < amount) return false;

        // spend points and return true
        skillPoints -= amount;
        OnSPChanged?.Invoke(skillPoints);
        return true;
    }

    // XP required for next level
    public int GetXPRequiredForNext()
    {
        int n = Mathf.Max(1, level);
        return xpBase + xpStep * (n - 1);
    }
}

// ----- File: P_Movement.cs -----
using System;
using UnityEngine;

public class P_Movement : MonoBehaviour
{
    [Header("Independent component to manage Player's movement and animation")]
    [Header("References")]
    Rigidbody2D rb;
    Animator animator;
    P_InputActions input;

    C_Stats c_Stats;
    C_State c_State;
    P_Combat p_Combat;
    C_Dodge c_Dodge;

    [Header("Facing / Animator")]
    public Vector2 lastMove = Vector2.down; // Default facing down

    // Runtime state
    bool disabled;      // When true, movement/animation stops
    Vector2 moveAxis;   // Desired direction of travel
    Vector2 velocity;   // Final velocity applied to Rigidbody2D.linearVelocity
    Vector2 knockback;

    const float MIN_DISTANCE = 0.0001f;

    void Awake()
    {
        rb ??= GetComponent<Rigidbody2D>();
        animator ??= GetComponent<Animator>();
        input ??= new P_InputActions();

        c_Stats ??= GetComponent<C_Stats>();
        p_Combat ??= GetComponent<P_Combat>();
        c_Dodge ??= GetComponent<C_Dodge>();
        c_State ??= GetComponent<C_State>();

        if (!rb) Debug.LogError($"{name}: Rigidbody2D in P_Movement missing.");
        if (!animator) Debug.LogError($"{name}: Animator in P_Movement missing.");

        if (!c_Stats) Debug.LogError($"{name}: C_Stats in P_Movement missing.");
        if (!p_Combat) Debug.LogError($"{name}: P_Combat in P_Movement missing.");
        if (!c_Dodge) Debug.LogError($"{name}: C_Dodge in P_Movement missing.");
        if (!c_State) Debug.LogError($"{name}: C_State in P_Movement missing.");

        animator?.SetFloat("moveX", 0f);
        animator?.SetFloat("moveY", -1f);
    }

    void OnEnable() => input.Enable();
    void OnDisable() => input.Disable();

    void Update()
    {
        // Normalize to avoid diagonal speed advantage
        // If raw is near zero, x,y = 0
        Vector2 raw = input.Player.Move.ReadValue<Vector2>();
        Vector2 desired = raw.sqrMagnitude > MIN_DISTANCE ? raw.normalized : Vector2.zero;

        SetMoveAxis(desired);
        
        // Do not override lastMove when attacking
        // Attack facing is stored separately in animator atkX/atkY so movement (WASD) still controls idle facing
        c_State.UpdateAnimDirections(moveAxis, lastMove);
    }


    void FixedUpdate()
    {
        Vector2 forced  = c_Dodge.ForcedVelocity;
        Vector2 baseVel = (forced != Vector2.zero) ? forced : velocity;
        Vector2 final   = baseVel + knockback;
        rb.linearVelocity = final;


        if (knockback.sqrMagnitude > 0f)
        {
            float step = c_Stats.KR * Time.fixedDeltaTime;
            knockback = Vector2.MoveTowards(knockback, Vector2.zero, step);
        }
    }


    void SetMoveAxis(Vector2 v)
    {
        if (disabled)
        {
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            return;
        }

        // Only fire direction event if direction actually changed.
        if (moveAxis != v && v.sqrMagnitude > MIN_DISTANCE)
        {
            lastMove = v; // Idle facing uses latest non-zero direction
        }

        moveAxis = v;

        // Valve is closed when disabled OR lockDuringAttack
        bool valveClosed = disabled || c_State.CheckIsBusy();
        // If valve is closed, stop; otherwise apply intended velocity
        Vector2 intendedVelocity = moveAxis * c_Stats.MS;
        velocity = valveClosed ? Vector2.zero : intendedVelocity;
    }

    public void SetDisabled(bool isDisabled)
    {
        disabled = isDisabled;
        if (isDisabled)
        {
            moveAxis = Vector2.zero;
            velocity = Vector2.zero;
            rb.linearVelocity = Vector2.zero; // immediate stop
        }
    }

    public void ReceiveKnockback(Vector2 force) => knockback += force;

}

// ----- File: P_StatsChanged.cs -----
using UnityEngine;
using System;

[DisallowMultipleComponent]
public class P_StatsChanged : MonoBehaviour
{
    [Header("Independent component to manage Player's stats changed by Skill Tree")]
    [Header("References")]
    C_Stats c_Stats;
    C_Health c_Health;

    // Baseline snapshot
    int baseAD, baseAP, baseMaxHP, baseAR, baseMR;
    float baseMS, baseKR;

    // Upgrades
    int upAD, upAP, upHP, upAR, upMR;
    float upMS, upKR;

    // Lifesteal
    public bool lifestealUnlocked = false;
    [Range(0f, 1f)] public float lifestealPercent = 0f;

    public event Action OnStatsRecalculated;

    void Awake()
    {
        c_Stats ??= GetComponent<C_Stats>();
        c_Health ??= GetComponent<C_Health>();

        if (!c_Stats) Debug.LogError($"{name}: C_Stats missing in P_Skills.", this);
        if (!c_Health) Debug.LogError($"{name}: C_Health missing in P_Skills.", this);

        baseAD = c_Stats.AD;
        baseAP = c_Stats.AP;
        baseMaxHP = c_Stats.maxHP;
        baseAR = c_Stats.AR;
        baseMR = c_Stats.MR;
        baseMS = c_Stats.MS;
        baseKR = c_Stats.KR;

        Recalculate();
    }

    // Called by SkillManager when a node upgrades
    public void ApplyStat(ST_SkillSO.Stat stat, int delta)
    {
        switch (stat)
        {
            case ST_SkillSO.Stat.AD: upAD += delta; break;
            case ST_SkillSO.Stat.AP: upAP += delta; break;
            case ST_SkillSO.Stat.MaxHP: upHP += delta; break;
            case ST_SkillSO.Stat.AR: upAR += delta; break;
            case ST_SkillSO.Stat.MR: upMR += delta; break;
            case ST_SkillSO.Stat.MS: upMS += delta; break;
            case ST_SkillSO.Stat.KR: upKR += delta; break;
        }
        Recalculate();
    }

    public void SetLifestealPercent(float percent)
    {
        lifestealUnlocked = percent > 0f;
        lifestealPercent = percent;
    }

    void Recalculate()
    {
        // Recalculate all stats based on base values + upgrades
        c_Stats.AD = baseAD + upAD;
        c_Stats.AP = baseAP + upAP;
        c_Stats.maxHP = baseMaxHP + upHP;
        c_Stats.AR = baseAR + upAR;
        c_Stats.MR = baseMR + upMR;
        c_Stats.MS = baseMS + upMS;
        c_Stats.KR = baseKR + upKR;

        // Announce that stats have been updated
        OnStatsRecalculated?.Invoke();
    }

    // Heal when the PLAYER deals final damage (wire from weapon/hit pipeline)
    public void OnDealtDamage(int finalDamage)
    {
        if (!lifestealUnlocked || finalDamage <= 0) return;
        int heal = Mathf.RoundToInt(finalDamage * lifestealPercent);
        if (heal > 0) c_Health.ChangeHealth(heal);
    }
}

