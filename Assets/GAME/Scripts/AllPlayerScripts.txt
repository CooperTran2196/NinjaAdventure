// ----- File: P_Controller.cs -----
using System.Collections;
using UnityEngine;
using UnityEngine.InputSystem;

[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(P_State_Idle))]
[RequireComponent(typeof(P_State_Movement))]
[RequireComponent(typeof(P_State_Attack))]
[RequireComponent(typeof(P_State_Dodge))]
[RequireComponent(typeof(C_Stats))]
[RequireComponent(typeof(C_Health))]

public class P_Controller : MonoBehaviour
{
    public enum PState { Idle, Move, Attack, Dodge, Dead }

    [Header("Main controller for player input states")]
    [Header("References")]
    public PState defaultState = PState.Idle;
    public PState currentState;

    [Header("Weapons")]
    public W_Base meleeWeapon;
    public W_Base rangedWeapon;

    [Header("Debug")]
    public bool autoKill;

    Rigidbody2D rb;
    Animator anim;
    P_InputActions input;

    P_State_Idle idle;
    P_State_Movement move;
    P_State_Attack attack;
    P_State_Dodge dodge;
    C_Stats c_Stats;
    C_Health c_Health;

    // Runtime vars - grouped by type
    Vector2 desiredVelocity, knockback, moveAxis, attackDir = Vector2.down, lastMove = Vector2.down;
    bool isDead, isStunned, isAttacking, isDodging;
    float stunUntil, attackCooldown, dodgeCooldown;
    W_Base currentWeapon;

    const float MIN_DISTANCE = 0.000001f;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        anim = GetComponent<Animator>();
        c_Stats = GetComponent<C_Stats>();
        c_Health = GetComponent<C_Health>();

        idle = GetComponent<P_State_Idle>();
        move = GetComponent<P_State_Movement>();
        attack = GetComponent<P_State_Attack>();
        dodge = GetComponent<P_State_Dodge>();  // Changed from State_Dodge to P_State_Dodge

        input ??= new P_InputActions();

        anim.SetFloat("moveX", 0f);
        anim.SetFloat("moveY", -1f);
        anim.SetFloat("idleX", 0f);
        anim.SetFloat("idleY", -1f);
    }

    void OnEnable()
    {
        input.Enable();
        c_Health.OnDied += OnDiedHandler;
        SwitchState(defaultState);
    }

    void OnDisable()
    {
        input.Disable();
        c_Health.OnDied -= OnDiedHandler;
        idle.enabled = move.enabled = attack.enabled = dodge.enabled = false;
    }

    void OnDiedHandler() => SwitchState(PState.Dead);

    void Update()
    {
        if (isDead || isStunned) return;
        if (attackCooldown > 0f) attackCooldown -= Time.deltaTime;
        if (dodgeCooldown > 0f) dodgeCooldown -= Time.deltaTime;

        // Debug kill
        if (autoKill) { autoKill = false; c_Health.ChangeHealth(-c_Stats.maxHP); }

        // PROCESS INPUTS
        ProcessInputs();
    }

    void FixedUpdate()
    {
        if (isDead) return;

        // Apply this frame: block state intent when stunned/dead, but still allow knockback
        Vector2 baseVel = isStunned ? Vector2.zero : desiredVelocity;
        rb.linearVelocity = baseVel + knockback;

        // Decay knockback for the NEXT frame (always decay - MoveTowards handles zero gracefully)
        knockback = Vector2.MoveTowards(knockback, Vector2.zero, c_Stats.KR * Time.fixedDeltaTime);
    }

    // Convert mouse position to world direction
    Vector2 ReadMouseAim()
    {
        Vector2 m = Mouse.current.position.ReadValue();
        var cam = Camera.main;
        if (!cam) return Vector2.zero;
        Vector3 world = cam.ScreenToWorldPoint(new Vector3(m.x, m.y, -cam.transform.position.z));
        Vector2 dir = (Vector2)world - (Vector2)transform.position;
        return dir.sqrMagnitude > MIN_DISTANCE ? dir.normalized : Vector2.zero;
    }

    void ProcessInputs()
    {
        // Handle death first (highest)
        if (c_Stats.currentHP <= 0)
        {
            SwitchState(PState.Dead);
            return;
        }

        // Don't interrupt while atacking or dodging
        if (currentState == PState.Attack && isAttacking) return;
        if (currentState == PState.Dodge && isDodging) return;

        // Handle dodge input (high)
        if (input.Player.Dodge.triggered && dodgeCooldown <= 0f)
        {
            SwitchState(PState.Dodge);
            return;
        }

        // Handle attack inputs (mid)
        if (attackCooldown <= 0f)
        {
            Vector2 mouseAim = ReadMouseAim();
            if (mouseAim != Vector2.zero) attackDir = mouseAim;

            if (input.Player.MeleeAttack.triggered)
            {
                currentWeapon = meleeWeapon;
                SwitchState(PState.Attack);
                return;
            }
            if (input.Player.RangedAttack.triggered)
            {
                currentWeapon = rangedWeapon;
                SwitchState(PState.Attack);
                return;
            }
        }

        // Handle movement input (low priority)
        moveAxis = input.Player.Move.ReadValue<Vector2>();
        if (moveAxis.sqrMagnitude > 1f) moveAxis.Normalize();

        if (moveAxis.sqrMagnitude > MIN_DISTANCE)
        {
            lastMove = moveAxis;

            // Continue moving if already in Move state
            if (currentState == PState.Move)
            {
                // refresh axis without flipping states
                move.SetMoveAxis(moveAxis);
            }
            else // Switch to Move state if not already
            {
                SwitchState(PState.Move);
                move.SetMoveAxis(moveAxis);
            }
            return;
        }

        // Default to idle (lowest priority)
        SwitchState(PState.Idle);
    }

    // Switch states with integrated death handling and attack logic
    public void SwitchState(PState state)
    {
        if (currentState == state) return;
        currentState = state;

        // Disable all states first
        idle.enabled = move.enabled = attack.enabled = dodge.enabled = false;

        switch (state)
        {
            case PState.Dead: // Highest priority
                desiredVelocity = Vector2.zero;
                knockback = Vector2.zero;
                rb.linearVelocity = Vector2.zero;
                isDead = true;
                isAttacking = false;
                isStunned = false;
                isDodging = false;

                anim.SetTrigger("Die");
                break;

            case PState.Dodge:
                dodge.enabled = true;
                isDodging = true;
                dodgeCooldown = c_Stats.dodgeCooldown;

                dodge.Dodge(lastMove);
                break;

            case PState.Attack:
                desiredVelocity = Vector2.zero;
                attack.enabled = true;

                if (currentWeapon != null)
                {
                    attackCooldown = c_Stats.attackCooldown;
                    isAttacking = true;
                    attack.Attack(currentWeapon, attackDir);
                    currentWeapon = null;
                }
                break;

            case PState.Move:
                move.enabled = true;

                move.SetMoveAxis(moveAxis);
                break;

            case PState.Idle: // Lowest priority
                desiredVelocity = Vector2.zero;
                idle.enabled = true;

                idle.SetIdleFacing(lastMove);
                break;
        }
    }

    // STUN FEATURE (same as enemy)
    public IEnumerator StunFor(float duration)
    {
        if (duration <= 0f) yield break;

        // Extend the stun end if a longer one arrives
        float newEnd = Time.time + duration;
        if (newEnd > stunUntil) stunUntil = newEnd;

        isStunned = true;
        while (Time.time < stunUntil) yield return null;

        isStunned = false;
    }

    public void SetDesiredVelocity(Vector2 desiredVelocity) => this.desiredVelocity = desiredVelocity;
    public void ReceiveKnockback(Vector2 knockback) => this.knockback += knockback;
    // State setters for external components
    public void SetAttacking(bool value) => isAttacking = value;
    public void SetDodging(bool value) => isDodging = value;
}

// ----- File: P_Exp.cs -----
using UnityEngine;
using System;

[DisallowMultipleComponent]
public class P_Exp : MonoBehaviour
{
    [Header("Independent component to manage Player's XP, Level, and Skill Points")]
    [Header("Progression Stats")]
    public int level = 1;
    public int currentExp = 0;
    public int skillPoints = 0;
    public int totalKills = 0;
    public float playTime = 0f;

    [Header("XP Curve Settings")]
    public int xpBase = 60;      // L1 -> L2
    public int xpStep = 30;      // linear add per level
    public int skillPointsPerLevel = 2;

    [Header("Debug")]
    public int debugXPAmount = 20;

    public event Action<int>        OnLevelUp;
    public event Action<int,int>    OnXPChanged;
    public event Action<int>        OnSPChanged;

    void Start()
    {
        OnXPChanged?.Invoke(currentExp, GetXPRequiredForNext());
    }

    void Update()
    {
        // Track total time played
        playTime += Time.deltaTime;
    }

    public void AddDebugXP()
    {
        AddXP(debugXPAmount);
    }

    // Called by enemies when they die
    public void AddKill()
    {
        totalKills++;
    }

    // Add XP and handle level up
    public void AddXP(int amount)
    {
        if (amount <= 0) return;

        // Add XP and check for level up
        currentExp += amount;
        int req = GetXPRequiredForNext();

        // Level up while enough XP for next level
        while (currentExp >= req)
        {
            currentExp -= req;
            level++;
            skillPoints += skillPointsPerLevel;

            OnLevelUp?.Invoke(level);
            OnSPChanged?.Invoke(skillPoints);

            req = GetXPRequiredForNext();
        }

        OnXPChanged?.Invoke(currentExp, req);
    }

    // Return true if successfully spent points
    public bool TrySpendSkillPoints(int amount)
    {
        // return false if not enough points
        if (amount <= 0) return false;
        if (skillPoints < amount) return false;

        // spend points and return true
        skillPoints -= amount;
        OnSPChanged?.Invoke(skillPoints);
        return true;
    }

    // XP required for next level
    public int GetXPRequiredForNext()
    {
        int n = Mathf.Max(1, level);
        return xpBase + xpStep * (n - 1);
    }

    public SYS_SaveSystem.ProgressSave SavingProgress()
{
    // gold is canonical in inventory; we mirror it here only if you want it in Progress too
    int goldMirror = INV_Manager.Instance ? INV_Manager.Instance.gold : 0; // :contentReference[oaicite:2]{index=2}

    return new SYS_SaveSystem.ProgressSave
    {
        level       = level,
        currentExp  = currentExp,
        skillPoints = skillPoints,
        totalKills  = totalKills,
        playTime    = playTime,
        goldMirror  = goldMirror
    };
}

public void LoadingProgress(SYS_SaveSystem.ProgressSave save)
{
    if (save == null) return;

    // restore core progression
    level       = save.level;
    currentExp  = save.currentExp;
    skillPoints = save.skillPoints;
    totalKills  = save.totalKills;
    playTime    = save.playTime;

    // tell any listeners (UI) to refresh
    OnXPChanged?.Invoke(currentExp, GetXPRequiredForNext()); // refresh bars
    OnSPChanged?.Invoke(skillPoints);                        // refresh SP text

    // NOTE: We don't invoke OnLevelUp on load (that’s for *earning* a level, not restoring one)
}

}

// ----- File: P_StatEffect.cs -----
using System;
using UnityEngine;

// A central enum for all stats that can be modified
public enum StatName
{
    // Core Stats
    AttackDamage,
    AbilityPower,
    MoveSpeed,
    MaxHealth,
    Armor,
    MagicResist,
    ArmorPen,
    MagicPen,
    KnockbackResist,

    // Special Stats
    Lifesteal,

    // Consumable Stats
    Heal,
}

// Core definition for any change to a stat
[Serializable]
public class P_StatEffect
{
    public StatName statName;
    public float Value;

    [Header("0 = Permanent, 1 = Instant, >1 = Timed Effect")]
    public int Duration = 1;

    [Header("Tick Effect (for Duration > 1, Only Heal)")]
    [Header("True = Repeatedly, once per second")]
    [Header("False = One-time at start")]
    public bool IsOverTime = false;
}

// ----- File: P_State_Attack.cs -----
using System.Collections;
using UnityEngine;

public class P_State_Attack : MonoBehaviour
{
    [Header("References")]
    public W_Base  activeWeapon;
    public Vector2 attackDir;

    [Header("Attack Timings")]
    float attackDuration = 0.45f;
    float hitDelay       = 0.15f;

    // Cache
    Animator anim;
    P_Controller controller;

    void Awake()
    {
        anim        = GetComponent<Animator>();
        controller  = GetComponent<P_Controller>();
    }

    void OnEnable()
    {
        anim.SetBool("isAttacking", true); // animator enter
    }

    void OnDisable()
    {
        StopAllCoroutines(); // If player dies -> stop attack immediately
        anim.SetBool("isAttacking", false); // Exit Attack animation by bool
        controller.SetAttacking(false); // Normal finish
    }

    void Update()
    {
        // OPTIONAL: Keep idle facing towards attack direction - else use last movement direction
        // anim.SetFloat("moveX", 0f);
        // anim.SetFloat("moveY", 0f);
        // anim.SetFloat("idleX", attackDir.x);
        // anim.SetFloat("idleY", attackDir.y);
    }

    // Attack with weapon and direction (called by controller)
    public void Attack(W_Base activeWeapon, Vector2 attackDir)
    {
        this.activeWeapon = activeWeapon;
        this.attackDir = attackDir; // Controller already normalized

        anim.SetFloat("atkX", attackDir.x);
        anim.SetFloat("atkY", attackDir.y);

        StartCoroutine(AttackRoutine());
    }

    // Just handles animation timing
    IEnumerator AttackRoutine()
    {
        yield return new WaitForSeconds(hitDelay);
        activeWeapon.Attack(attackDir);
        yield return new WaitForSeconds(attackDuration - hitDelay);

        controller.SetAttacking(false); // Interrupted by Dead
    }
}

// ----- File: P_State_Dodge.cs -----
using System.Collections;
using UnityEngine;

[DisallowMultipleComponent]
public class P_State_Dodge : MonoBehaviour
{
    // Cache
    Animator anim;
    C_Stats stats;
    P_Controller controller;
    C_AfterimageSpawner afterimage;

    // Runtime
    Vector2 dodgeDir;
    float dodgeDuration;

    void Awake()
    {
        anim        ??= GetComponent<Animator>();
        stats       ??= GetComponent<C_Stats>();
        controller  ??= GetComponent<P_Controller>();
        afterimage  ??= GetComponent<C_AfterimageSpawner>();

        if (!anim)       Debug.LogError("State_Dodge: Missing Animator");
        if (!stats)      Debug.LogError("State_Dodge: Missing C_Stats");
        if (!controller) Debug.LogError("State_Dodge: Missing P_Controller");
        if (!afterimage) Debug.LogError("State_Dodge: Missing C_AfterimageSpawner");
    }

    void OnEnable()
    {
        anim.SetBool("isDodging", true);
    }

    void OnDisable()
    {
        StopAllCoroutines(); // If player dies -> stop attack immediately
        anim.SetBool("isDodging", false); // Exit Attack animation by bool
        controller.SetDodging(false); // Normal finish
    }

    public void Dodge(Vector2 dir)
    {
        dodgeDir = dir;

        // Compute duration from distance & speed
        float speed    = stats.dodgeSpeed;
        float distance = stats.dodgeDistance;
        dodgeDuration  = distance / speed; // assume valid per your inspector preconditions

        // One-time velocity set; controller keeps applying desiredVelocity each FixedUpdate
        controller.SetDesiredVelocity(dodgeDir * speed);

        // Lock current sprite for the whole trail burst
        var sr          = GetComponent<SpriteRenderer>();
        var lockedSprite= sr ? sr.sprite : null;
        bool flipX      = sr && sr.flipX;
        bool flipY      = sr && sr.flipY;

        afterimage?.StartBurst(dodgeDuration, lockedSprite, flipX, flipY);

        StartCoroutine(DodgeRoutine());
    }

    IEnumerator DodgeRoutine()
    {
        yield return new WaitForSeconds(dodgeDuration);

        controller.SetDodging(false); // Interrupted by Dead
    }
}

// ----- File: P_State_Idle.cs -----
using UnityEngine;

[DisallowMultipleComponent]
public class P_State_Idle : MonoBehaviour
{
    // Cache
    Animator anim;
    P_Controller controller;

    // Runtime
    public Vector2 lastFaceDirection = Vector2.down;

    void Awake()
    {
        anim = GetComponent<Animator>();
        controller = GetComponent<P_Controller>();

        if (!anim) Debug.LogError("P_State_Idle: missing Animator");
        if (!controller) Debug.LogError("P_State_Idle: missing P_Controller");
    }

    // Set the idle facing direction
    public void SetIdleFacing(Vector2 direction)
    {
        // Controller guarantees normalized input per your rule.
        lastFaceDirection = direction;
        anim.SetFloat("idleX", lastFaceDirection.x);
        anim.SetFloat("idleY", lastFaceDirection.y);
    }
}

// ----- File: P_State_Movement.cs -----
using UnityEngine;

[DisallowMultipleComponent]
public class P_State_Movement : MonoBehaviour
{
    // Cache
    Animator     anim;
    C_Stats      c_Stats;
    P_Controller controller;

    // Runtime
    Vector2      moveAxis;

    void Awake()
    {
        anim        = GetComponent<Animator>();
        c_Stats     = GetComponent<C_Stats>();
        controller  = GetComponent<P_Controller>();
    }

    void OnEnable()
    {
        anim.SetBool("isMoving", true);
    }

    void OnDisable()
    {
        controller.SetDesiredVelocity(Vector2.zero);
        anim.SetBool("isMoving", false);
        anim.SetFloat("moveX", 0f);
        anim.SetFloat("moveY", 0f);
    }

    void Update()
    {
        // Calculate and apply movement velocity
        controller.SetDesiredVelocity(moveAxis * c_Stats.MS);

        // Set movement animation
        anim.SetFloat("moveX", moveAxis.x);
        anim.SetFloat("moveY", moveAxis.y);
    }

    // Move with given axis, ontroller already normalized this
    public void SetMoveAxis(Vector2 moveAxis) => this.moveAxis = moveAxis;
}

// ----- File: P_StatsManager.cs -----
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

[DisallowMultipleComponent]
public class P_StatsManager : MonoBehaviour
{
    [Header("Depend on C_Stats and C_Health")]

    [Header("References")]
    C_Stats c_Stats;
    C_Health c_Health;

    // Base stats that can be modified
    private int baseAD, baseAP, baseMaxHP, baseAR, baseMR;
    private float baseMS, baseKR, baseLifesteal, baseArmorPen, baseMagicPen;

    // List of temporary buffs/debuffs.
    private readonly List<P_StatEffect> statsEffectList = new List<P_StatEffect>();

    public event Action OnStatsChanged;

    void Awake()
    {
        c_Stats  ??= GetComponent<C_Stats>();
        c_Health ??= GetComponent<C_Health>();

        if (!c_Stats)  Debug.LogError($"{name}: C_Stats is missing in P_StatsManager");
        if (!c_Health) Debug.LogError($"{name}: C_Health is missing in P_StatsManager");

        // Make copy of basic Stats
        baseAD      = c_Stats.AD;
        baseAP      = c_Stats.AP;
        baseMS      = c_Stats.MS;
        baseMaxHP   = c_Stats.maxHP;
        baseAR      = c_Stats.AR;
        baseMR      = c_Stats.MR;
        baseKR      = c_Stats.KR;

        // Special stats
        baseLifesteal = c_Stats.lifesteal;
        baseArmorPen  = c_Stats.armorPen;
        baseMagicPen  = c_Stats.magicPen;
    }

    /// The main entry point for applying any stat change
    public void ApplyModifier(P_StatEffect stat)
    {
        // Duration == 0 is a PERMANENT
        if (stat.Duration == 0)
        {
            ApplyPermanentEffect(stat);
            RecalculateAllStats();
            return;
        }

        // Duration == 1 is an INSTANT, treat as permanent for stat boosts
        if (stat.Duration == 1)
        {
            // Instantaneous effects like Heal are handled directly
            if (stat.statName == StatName.Heal)
            {
                CommitStatChange(stat.statName, stat.Value);
            }
            // Other stat changes are made permanent
            else
            {
                ApplyPermanentEffect(stat);
                RecalculateAllStats();
            }
            return;
        }

        // Duration > 1 is a OVER TIME effect
        if (stat.Duration > 1)
        {
            if (stat.IsOverTime)
            {
                // Repeatedly, once per second
                StartCoroutine(ApplyOverTimeEffect(stat));
            }
            else
            {
                // One-time at start
                statsEffectList.Add(stat);
                RecalculateAllStats();
                StartCoroutine(StartEffectTimer(stat));
            }
        }
    }

    /// Handles permanent stat changes
    private void ApplyPermanentEffect(P_StatEffect stat)
    {
        // Apply the permanent change to the BASE stat
        switch (stat.statName)
        {
            case StatName.AttackDamage:     baseAD      += (int)stat.Value; break;
            case StatName.AbilityPower:     baseAP      += (int)stat.Value; break;
            case StatName.MoveSpeed:        baseMS      +=      stat.Value; break;
            case StatName.MaxHealth:        baseMaxHP   += (int)stat.Value; break;
            case StatName.Armor:            baseAR      += (int)stat.Value; break;
            case StatName.MagicResist:      baseMR      += (int)stat.Value; break;
            case StatName.KnockbackResist:  baseKR      +=      stat.Value; break;

            case StatName.Lifesteal:        baseLifesteal += stat.Value; break;
            case StatName.ArmorPen:         baseArmorPen  += stat.Value; break;
            case StatName.MagicPen:         baseMagicPen  += stat.Value; break;
            case StatName.Heal:             c_Health.ChangeHealth((int)stat.Value); break; // Permanent heal is just an instant heal
        }
    }

    /// Recalculates final stats based on: Base Stats + Flat Buffs
    public void RecalculateAllStats()
    {
        // 1/ Reset stats to their current base values
        c_Stats.AD      = baseAD;
        c_Stats.AP      = baseAP;
        c_Stats.MS      = baseMS;
        c_Stats.maxHP   = baseMaxHP;
        c_Stats.AR      = baseAR;
        c_Stats.MR      = baseMR;
        c_Stats.KR      = baseKR;

        c_Stats.lifesteal = baseLifesteal;
        c_Stats.armorPen  = baseArmorPen;
        c_Stats.magicPen  = baseMagicPen;

        // 2/ Find all active effects and apply them
        foreach (var stat in statsEffectList)
        {
            CommitStatChange(stat.statName, stat.Value);
        }

        // Ensure current health is clamped after any MaxHP changes.
        c_Stats.currentHP = Mathf.Min(c_Stats.currentHP, c_Stats.maxHP);

        OnStatsChanged?.Invoke();
    }

    /// Applies temporary adjustments on top of the base stats
    private void CommitStatChange(StatName statName, float value)
    {
        switch (statName)
        {

            case StatName.AttackDamage:     c_Stats.AD      += (int)value; break;
            case StatName.AbilityPower:     c_Stats.AP      += (int)value; break;
            case StatName.MoveSpeed:        c_Stats.MS      +=      value; break;
            case StatName.MaxHealth:        c_Stats.maxHP   += (int)value; break;
            case StatName.Armor:            c_Stats.AR      += (int)value; break;
            case StatName.MagicResist:      c_Stats.MR      += (int)value; break;
            case StatName.KnockbackResist:  c_Stats.KR      +=      value; break;

            case StatName.Lifesteal:        c_Stats.lifesteal += value; break;
            case StatName.ArmorPen:         c_Stats.armorPen  += value; break;
            case StatName.MagicPen:         c_Stats.magicPen  += value; break;
            case StatName.Heal:             c_Health.ChangeHealth((int)value); break;
        }
    }

    // Timer for temporary effects
    private IEnumerator StartEffectTimer(P_StatEffect stat)
    {
        yield return new WaitForSeconds(stat.Duration);
        statsEffectList.Remove(stat);
        RecalculateAllStats();
    }

    // Over-time effects (1 per second)
    private IEnumerator ApplyOverTimeEffect(P_StatEffect stat)
    {
        // RULE: Only allow ticking effects for Heal
        if (stat.statName != StatName.Heal)
        {
            Debug.LogWarning($"Stat Effect for {stat.statName} has IsOverTime=true, but this is only supported for Heal. Ignoring.", this);
            yield break;
        }

        // Repeat once per second for the duration
        int timePassed = 0;
        while (timePassed < stat.Duration)
        {
            yield return new WaitForSeconds(1);
            // Apply one "tick" of the effect
            CommitStatChange(stat.statName, stat.Value);
            timePassed += 1;
        }
    }
}

